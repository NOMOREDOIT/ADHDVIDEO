<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><title>Movie Meme Maker Studio</title><link rel="icon" type="image/png" href="favicon.ico"><link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet"><style>:root{--bg:#f2efe8;--ink:#2b2b2b;--mid:#c2c2c2;--light:#faf9f5;--light-rgb:250,249,245;--shadow:#7a7a7a;--danger-color:#cc4444;--action-color:#4477cc;--success-color:#55cc55}html{box-sizing:border-box}*,*:before,*:after{box-sizing:inherit}body{font-family:'VT323', monospace;background:var(--bg) url('./assets/wallpaper.png') repeat fixed;color:var(--ink);display:flex;flex-direction:column;align-items:center;padding:10px;margin:0;height:100vh;overflow:hidden}.window{background:var(--light);border:2px solid var(--ink);box-shadow:4px 4px 0px var(--ink);width:100%;max-width:1600px;margin:0 auto;height:calc(100vh - 20px);display:flex;flex-direction:column;overflow:hidden}.titlebar{height:28px;background:var(--mid);display:flex;align-items:center;justify-content:space-between;padding:0 8px;border-bottom:2px solid var(--ink);font-size:20px;flex-shrink:0;cursor:default;position:relative}.titlebar-controls{display:flex;align-items:center;gap:8px}.controls-fake{display:flex;gap:4px}.btn-square{width:16px;height:16px;background:var(--light);border:2px solid var(--ink)}.controls-fake .btn-square:first-child{background-color:var(--success-color)}.controls-fake .btn-square:last-child{background-color:var(--danger-color)}#shortcuts-btn,#visuals-btn,#audio-btn,#text-btn{font-family:inherit;font-size:16px;background:var(--light);border:2px solid var(--ink);padding:0 8px;cursor:pointer}#shortcuts-dropdown{display:none;position:absolute;top:28px;right:8px;background:var(--light);border:2px solid var(--ink);box-shadow:4px 4px 0px var(--ink);padding:.5rem 1rem;z-index:100;width:250px}#shortcuts-dropdown.visible{display:block}#shortcuts-dropdown h5{margin:0 0 .5rem 0;font-size:1.2rem;text-align:center}#shortcuts-dropdown ul{margin:0;padding:0;list-style:none;font-size:1rem}#shortcuts-dropdown li{display:flex;justify-content:space-between;padding:2px 0}#shortcuts-dropdown li kbd{font-family:inherit;border:2px solid var(--ink);padding:0 4px;background:var(--bg)}#visuals-dropdown,#audio-dropdown,#text-dropdown{display:none;position:absolute;top:28px;background:rgba(var(--light-rgb),.3);backdrop-filter:blur(4px);-webkit-backdrop-filter:blur(4px);border:2px solid var(--ink);box-shadow:4px 4px 0px var(--ink);padding:.5rem 1rem;z-index:100;width:250px;transition:background .2s,backdrop-filter .2s,box-shadow .2s,border-color .2s}#visuals-dropdown{right:320px}#text-dropdown{right:216px}#audio-dropdown{right:102px}#visuals-dropdown.visible,#audio-dropdown.visible,#text-dropdown.visible{display:block}#visuals-dropdown h5,#visuals-dropdown h6,#visuals-dropdown .slider-container,#audio-dropdown h5,#audio-dropdown p,#audio-dropdown .action-buttons,#text-dropdown h5,#text-dropdown h6,#text-dropdown .slider-container{transition:opacity .2s}#visuals-dropdown h5,#audio-dropdown h5,#text-dropdown h5{margin:0 0 .5rem 0;font-size:1.2rem;text-align:center}#visuals-dropdown h6,#text-dropdown h6{font-size:1.1rem;font-weight:bold;text-align:left;margin-top:.5rem;margin-bottom:.5rem;border-bottom:2px solid var(--mid);padding-bottom:2px}#visuals-dropdown label,#text-dropdown label{display:block;margin-top:.5rem;font-size:.9rem}#visuals-dropdown.is-scrubbing{background:transparent;backdrop-filter:none;-webkit-backdrop-filter:none;box-shadow:none;border-color:transparent}#visuals-dropdown.is-scrubbing>h5,#visuals-dropdown.is-scrubbing>div>h6,#visuals-dropdown.is-scrubbing .slider-container{opacity:0;pointer-events:none}#visuals-dropdown.is-scrubbing .slider-container.is-active-slider{opacity:1;pointer-events:auto}#visuals-dropdown input[type="range"],#text-dropdown input[type="range"]{width:100%;-webkit-appearance:none;appearance:none;height:2px;background:var(--ink);outline:none}#visuals-dropdown input[type="range"]::-webkit-slider-thumb,#text-dropdown input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:var(--ink);border-radius:50%;cursor:pointer}#visuals-dropdown input[type="range"]::-moz-range-thumb,#text-dropdown input[type="range"]::-moz-range-thumb{width:16px;height:16px;background:var(--ink);border-radius:50%;cursor:pointer;border:none}#asset-visuals-controls.disabled,#text-visuals-controls.disabled,#audio-controls.disabled{opacity:.5;pointer-events:none}#audio-file-name{font-size:.9rem;text-align:center;word-break:break-all;padding:.5rem;background:var(--bg);border:2px inset var(--mid);min-height:40px}.mg-btn{font-family:inherit;font-size:18px;background:var(--light);border:2px solid var(--ink);padding:8px 16px;margin:4px;cursor:pointer;text-decoration:none;color:var(--ink);transition:.2s all;box-shadow:2px 2px 0px var(--shadow);width:100%;white-space:nowrap}.mg-btn:hover{transform:translate(2px,2px);box-shadow:0px 0px 0px var(--shadow)}.mg-btn:disabled,.mg-btn.disabled{opacity:.5;pointer-events:none;box-shadow:none;transform:none}.mg-btn.active{background-color:var(--danger-color);color:var(--light);box-shadow:none;transform:translate(2px,2px)}.mg-btn.success{background-color:var(--success-color)}.mg-btn.record{background-color:var(--danger-color);color:var(--light)}.mg-btn.generate{background-color:var(--ink);color:var(--light)}.hidden{display:none!important}#studio-container{display:grid;grid-template-columns:320px 1fr;grid-template-rows:minmax(0,1fr);gap:1.5rem;padding:1.5rem;flex-grow:1;min-height:0}#controls-panel{display:flex;flex-direction:column;gap:1rem;overflow-y:auto;min-height:0}#canvas-panel{display:flex;align-items:center;justify-content:center;border:2px solid var(--ink);background-color:var(--mid);position:relative;min-height:0}#controls-panel fieldset{background:var(--light);border:2px solid var(--ink);padding:.8rem;margin:0;text-align:left}#controls-panel legend{font-size:1.2rem;font-weight:normal;padding:0 .25rem}.action-buttons{display:grid;grid-template-columns:1fr 1fr;gap:.5rem}.scene-controls-container{display:flex;flex-direction:column;gap:.5rem}.scene-controls-container>.mg-btn{margin-left:0;margin-right:0}#scene-actions-container .mg-btn,#mg-commit-layer-btn{white-space:normal;text-align:center}#recording-status{display:flex;align-items:center;justify-content:center;gap:8px;font-size:1.2rem;color:var(--danger-color)}#recording-indicator{width:12px;height:12px;background-color:var(--danger-color);border:1px solid var(--ink);border-radius:50%;animation:blink 1s infinite}@keyframes blink{50%{opacity:.3}}.placeholder-text{color:var(--shadow);font-size:.9rem;text-align:center;padding:1rem;width:100%}#mg-asset-palette{display:flex;gap:.5rem;flex-wrap:wrap;min-height:70px;align-content:flex-start}.palette-slot,.layer-thumb{width:60px;height:60px;border:2px solid var(--ink);background:var(--light);cursor:pointer;position:relative;box-shadow:2px 2px 0px var(--shadow)}.layer-thumb.locked{opacity:.6;cursor:default;box-shadow:none}.layer-thumb.locked .layer-controls{display:none}.layer-thumb.locked:hover .layer-controls{display:flex}.layer-thumb{cursor:grab}.palette-slot.empty{display:flex;align-items:center;justify-content:center;font-size:3rem;line-height:1;color:var(--mid);transition:all .2s}.palette-slot.empty:hover{background-color:#e0e0e0;color:var(--ink)}.layer-thumb img,.layer-thumb video{width:100%;height:100%;object-fit:cover;pointer-events:none}.layer-thumb.active{border:2px solid var(--action-color);transform:scale(1.05);box-shadow:none}.layer-controls{position:absolute;top:-5px;right:-5px;display:flex;gap:2px}.layer-btn{background-color:var(--danger-color);border:1px solid var(--ink);color:#fff;font-size:.8rem;font-weight:bold;line-height:1;padding:1px 4px;cursor:pointer;width:18px;height:18px;text-align:center}#scene-tray{display:flex;gap:.5rem;flex-wrap:wrap;min-height:65px;align-content:flex-start;padding-bottom:.5rem;border-bottom:2px solid var(--mid);margin-bottom:.5rem}.scene-thumb{width:80px;height:55px;border:2px solid var(--ink);background-color:var(--mid);cursor:pointer;position:relative;box-shadow:2px 2px 0px var(--shadow);background-size:cover;background-position:center;display:flex;color:var(--light);text-shadow:1px 1px 0 var(--ink);align-items:center;justify-content:center;font-size:1.5rem;transition:all .2s}.scene-thumb.active{border-color:var(--action-color);transform:scale(1.05);box-shadow:0px 0px 0px var(--shadow)}.scene-delete-btn{position:absolute;top:-5px;right:-5px;background-color:var(--danger-color);border:1px solid var(--ink);color:#fff;font-size:.8rem;font-weight:bold;line-height:1;padding:1px 4px;cursor:pointer;width:18px;height:18px;text-align:center;opacity:0;transition:opacity .2s}.scene-thumb:hover .scene-delete-btn{opacity:1}.scene-thumb.active:hover .scene-delete-btn{display:none}#mg-movie-canvas,#mg-controls-overlay-canvas{position:absolute}#mg-controls-overlay-canvas{pointer-events:none}#mg-movie-canvas{pointer-events:auto}#video-volume-controls{position:absolute;bottom:10px;right:10px;display:flex;align-items:center;justify-content:flex-end;z-index:10;height:34px}#video-volume-btn{font-size:1.5rem;cursor:pointer;padding:4px;user-select:none;background:none;border:none}#volume-slider-wrapper{display:flex;align-items:center;width:0;opacity:0;overflow:hidden;transition:width .35s ease-in-out,opacity .35s ease-in-out}#video-volume-controls.open #volume-slider-wrapper{width:100px;opacity:1;margin-right:8px}#video-volume-slider{-webkit-appearance:none;appearance:none;width:100%;height:2px;background:var(--ink);outline:none}#video-volume-slider::-webkit-slider-thumb{-webkit-appearance:none;appearance:none;width:16px;height:16px;background:var(--ink);border-radius:50%;cursor:pointer}#video-volume-slider::-moz-range-thumb{width:16px;height:16px;background:var(--ink);border-radius:50%;cursor:pointer;border:none}.mg-overlay-base{position:fixed;top:0;left:0;width:100%;height:100%;z-index:1000;display:flex;align-items:center;justify-content:center;opacity:0;visibility:hidden;pointer-events:none;transition:opacity .3s,visibility 0s .3s;background:rgba(10,10,10,.25)}.mg-overlay-base.visible{opacity:1;visibility:visible;pointer-events:auto;transition:opacity .3s,visibility 0s 0s}.overlay-close-btn{position:absolute;top:8px;right:10px;background:none;border:none;line-height:1;cursor:pointer;padding:5px;font-family:'VT323', monospace;color:var(--ink);font-size:2rem;z-index:10;transition:opacity .2s}.overlay-close-btn:hover{opacity:.6}#mg-asset-picker-grid-wrapper{background:var(--light);border:2px solid var(--ink);box-shadow:4px 4px 0px var(--ink);padding:1.5rem;max-width:800px;width:90vw;max-height:85vh;display:flex;flex-direction:column;position:relative}#mg-asset-picker-grid-wrapper h4{font-size:1.5rem;text-align:center;font-weight:normal;margin:0 0 1rem}#mg-asset-picker-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(80px,1fr));gap:.5rem;overflow-y:auto;padding:.5rem;flex-grow:1}.mg-template{width:auto;height:80px}.mg-template img{width:100%;height:100%;object-fit:contain;cursor:pointer}#mg-asset-picker-actions{margin-top:1rem;text-align:center;display:flex;gap:.5rem;justify-content:center}#mg-toast{visibility:hidden;position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:var(--light);border:2px solid var(--ink);padding:.5rem 1rem;color:var(--ink);font-size:1rem;z-index:2000;box-shadow:4px 4px 0 var(--ink)}#mg-countdown-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:transparent;display:flex;align-items:center;justify-content:center;z-index:3000;color:var(--light);text-shadow:2px 2px 0 var(--ink),-2px -2px 0 var(--ink),2px -2px 0 var(--ink),-2px 2px 0 var(--ink);font-size:15vw;pointer-events:auto}#canvas-placeholder{position:absolute;width:calc(100% - 20px);height:calc(100% - 20px);border:4px dashed var(--shadow);border-radius:10px;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;cursor:pointer;color:var(--shadow);transition:all .2s;padding:2rem}#canvas-placeholder h3{font-size:2rem;margin:0 0 .5rem}#canvas-placeholder:hover,#canvas-panel.drag-over #canvas-placeholder{border-color:var(--ink);color:var(--ink);background-color:rgba(255,255,255,.5)}#canvas-panel.drag-over{background-color:var(--shadow)}#layer-instructions{padding:0 0 .5rem 0;margin:0;font-size:1rem}#mg-preview-container{position:relative;background:var(--light);border:2px solid var(--ink);box-shadow:4px 4px 0px var(--ink);padding:10px}#mg-preview-container .overlay-close-btn{top:-10px;right:-10px;background:var(--danger-color);color:var(--light);border:2px solid var(--ink)}#mg-preview-video{display:block;max-width:80vw;max-height:75vh;background:#000}#mg-generation-overlay{z-index:4000}#mg-generation-overlay .window{max-width:400px;height:auto;padding:2rem;text-align:center}#mg-generation-overlay h3{font-size:2rem;margin:0 0 1rem}#mg-confirmation-overlay{z-index:5000}#mg-confirmation-dialog{padding:1.5rem;text-align:center;width:90%;max-width:400px;height:auto}#mg-confirmation-dialog p{font-size:1.2rem;margin:0 0 1.5rem}#mg-confirmation-dialog .action-buttons{display:flex;justify-content:center}#scene-actions-container{grid-template-columns:2fr 1fr 1fr;gap:.5rem}#scene-actions-container #mg-record-layer-btn{font-size:20px}</style></head><body><div class="window"><div class="titlebar"><span>Movie-Maker-Studio.exe</span><div class="titlebar-controls"><button id="visuals-btn">Edit Visuals</button><div id="visuals-dropdown"><h5>Visuals Editor</h5><div id="asset-visuals-controls" class="disabled"><h6>Selected Asset</h6><div class="slider-container"><label for="asset-opacity">Opacity</label><input type="range" id="asset-opacity" min="0" max="1" step="0.01" value="1"></div><div class="slider-container"><label for="asset-brightness">Brightness</label><input type="range" id="asset-brightness" min="0" max="2" step="0.01" value="1"></div><div class="slider-container"><label for="asset-saturation">Saturation</label><input type="range" id="asset-saturation" min="0" max="2" step="0.01" value="1"></div></div><div id="background-visuals-controls"><h6>Background</h6><div class="slider-container"><label for="bg-brightness">Brightness</label><input type="range" id="bg-brightness" min="0" max="2" step="0.01" value="1"></div><div class="slider-container"><label for="bg-saturation">Saturation</label><input type="range" id="bg-saturation" min="0" max="2" step="0.01" value="1"></div></div></div><button id="text-btn">+ Add Text Layer</button><div id="text-dropdown"><h5>Text Editor</h5><div id="text-visuals-controls" class="disabled"><div class="slider-container"><label for="text-content">Text Content</label><input type="text" id="text-content" value="New Text" style="width:100%;font-family:inherit;font-size:1rem;padding:4px;border:2px solid var(--ink);background:var(--bg);"></div><div class="slider-container"><label for="text-font">Font</label><select id="text-font" style="width:100%;font-family:inherit;font-size:1rem;padding:4px;border:2px solid var(--ink);background:var(--bg);"><option value="'VT323', monospace">VT323</option><option value="Arial, sans-serif">Arial</option><option value="Verdana, sans-serif">Verdana</option><option value="Georgia, serif">Georgia</option><option value="Times New Roman, serif">Times New Roman</option><option value="Courier New, monospace">Courier New</option><option value="Impact, fantasy">Impact</option><option value="Comic Sans MS, cursive">Comic Sans MS</option></select></div><div class="slider-container"><label for="text-size">Size</label><input type="range" id="text-size" min="20" max="200" step="1" value="60"></div><div class="slider-container"><label for="text-color">Color</label><input type="color" id="text-color" value="#FFFFFF" style="width:100%;border:none;padding:0;"></div><div class="slider-container"><label for="text-opacity">Opacity</label><input type="range" id="text-opacity" min="0" max="1" step="0.01" value="1"></div><div class="slider-container"><label for="text-brightness">Brightness</label><input type="range" id="text-brightness" min="0" max="2" step="0.01" value="1"></div><div class="slider-container"><label for="text-saturation">Saturation</label><input type="range" id="text-saturation" min="0" max="2" step="0.01" value="1"></div></div></div><button id="audio-btn">Scene Audio</button><div id="audio-dropdown"><h5>Scene Audio</h5><div id="audio-controls"><p id="audio-file-name">No audio added.</p><div class="action-buttons"><label class="mg-btn">Upload<input type="file" id="scene-audio-input" accept="audio/*" style="display:none;"></label><button class="mg-btn" id="remove-audio-btn">Remove</button></div></div></div><button id="shortcuts-btn">Shortcuts</button><div class="controls-fake"><div class="btn-square"></div><div class="btn-square"></div></div><div id="shortcuts-dropdown"><h5>Keyboard Shortcuts</h5><ul><li><span>Start/Stop Recording</span><kbd>R</kbd></li><li><span>Enlarge Asset</span><kbd>D</kbd></li><li><span>Shrink Asset</span><kbd>F</kbd></li><li><span>Flip Asset Horizontally</span><kbd>S</kbd></li><li><span>Delete Asset</span><kbd>Delete</kbd></li></ul></div></div></div><main id="studio-container"><div id="controls-panel"><fieldset><legend>Scenes</legend><div id="scene-tray"></div><button class="mg-btn" id="add-scene-btn" style="margin-top:.5rem;" title="Add a new scene with an image or video background">+ Add Scene</button></fieldset><fieldset><legend>Layers</legend><p id="layer-instructions" class="placeholder-text">Create a scene to begin.</p><div id="mg-asset-palette"></div></fieldset><fieldset><legend>Current Scene</legend><div class="scene-controls-container"><div id="scene-actions-container" class="action-buttons"><button class="mg-btn record" id="mg-record-layer-btn" disabled>Record Layer</button><button class="mg-btn" id="mg-preview-scene-btn" disabled>Preview Scene</button><button class="mg-btn" id="mg-delete-scene-btn" disabled>Delete Scene</button></div><div id="stop-actions-container" class="action-buttons hidden"><button class="mg-btn active" id="mg-stop-layer-btn" style="grid-column:span 2;">Stop</button></div><div id="recording-status" class="hidden"><div id="recording-indicator"></div><span id="recording-timer">00:00</span></div><button class="mg-btn hidden" id="mg-commit-layer-btn">Commit Layer & Add Next</button></div></fieldset><fieldset><legend>Project</legend><button class="mg-btn generate" id="mg-generate-project-btn" disabled>Generate Project</button><div class="action-buttons" id="post-generation-actions" style="margin-top:.5rem;"><button class="mg-btn hidden" id="mg-preview-btn">Preview</button><button class="mg-btn hidden" id="mg-movie-download">Download</button></div></fieldset></div><div id="canvas-panel"><canvas id="mg-movie-canvas"></canvas><canvas id="mg-controls-overlay-canvas"></canvas><div id="canvas-placeholder"><h3>Click or Drag & Drop File</h3><p>to add a background image or video</p></div><div id="video-volume-controls" class="hidden"><div id="volume-slider-wrapper"><input type="range" id="video-volume-slider" min="0" max="1" step="0.05" value="1"></div><button id="video-volume-btn">🔊</button></div></div></main><input type="file" id="initial-background-input" accept="image/*,video/*" style="display:none;"></div><div id="mg-asset-library-overlay" class="mg-overlay-base"><div id="mg-asset-picker-grid-wrapper" class="window"><button id="mg-asset-library-close" class="overlay-close-btn">X</button><h4>Click an asset to add it to the canvas</h4><div id="mg-asset-picker-grid"></div><div id="mg-asset-picker-actions"><label class="mg-btn">Upload Custom<input type="file" id="mg-asset-picker-file" accept="image/png,video/mp4,video/quicktime,video/*" style="display:none;"></label></div></div></div><div id="mg-preview-popup" class="mg-overlay-base"><div id="mg-preview-container"><button id="mg-preview-close-btn" class="overlay-close-btn">X</button><video id="mg-preview-video" controls autoplay></video></div></div><div id="mg-generation-overlay" class="mg-overlay-base"><div class="window"><h3>Generating Project...</h3><p>Please wait while your scenes are combined into the final video.</p></div></div><div id="mg-confirmation-overlay" class="mg-overlay-base"><div id="mg-confirmation-dialog" class="window"><p id="mg-confirmation-text">Are you sure?</p><div class="action-buttons"><button id="mg-confirm-yes-btn" class="mg-btn active">Yes</button><button id="mg-confirm-no-btn" class="mg-btn">No</button></div></div></div><div id="mg-toast"></div><div id="mg-countdown-overlay" class="hidden"><span id="mg-countdown-span">3</span></div></body></html>
<script>
     (function () {
        // === DOM Elements ===
        const addSceneBtn = document.getElementById('add-scene-btn');
        const assetLibraryOverlay = document.getElementById('mg-asset-library-overlay');
        const assetPalette = document.getElementById('mg-asset-palette');
        const assetPickerFileInput = document.getElementById('mg-asset-picker-file');
        const canvasPanel = document.getElementById('canvas-panel');
        const controlsPanel = document.getElementById('controls-panel');
        const canvasPlaceholder = document.getElementById('canvas-placeholder');
        const controlsOverlayCanvas = document.getElementById('mg-controls-overlay-canvas');
        const controlsCtx = controlsOverlayCanvas.getContext('2d');
        const countdownOverlay = document.getElementById('mg-countdown-overlay');
        const countdownSpan = document.getElementById('mg-countdown-span');
        const initialBackgroundInput = document.getElementById('initial-background-input');
        const layerInstructions = document.getElementById('layer-instructions');
        const movieCanvas = document.getElementById('mg-movie-canvas');
        const movieCtx = movieCanvas.getContext('2d');
        const movieDownloadBtn = document.getElementById('mg-movie-download');
        const recordLayerBtn = document.getElementById('mg-record-layer-btn');
        const stopLayerBtn = document.getElementById('mg-stop-layer-btn');
        const sceneActionsContainer = document.getElementById('scene-actions-container');
        const stopActionsContainer = document.getElementById('stop-actions-container');
        const commitLayerBtn = document.getElementById('mg-commit-layer-btn');
        const recordingStatus = document.getElementById('recording-status');
        const recordingTimer = document.getElementById('recording-timer');
        const sceneTray = document.getElementById('scene-tray');
        const newSceneBackgroundInput = document.createElement('input');
        newSceneBackgroundInput.type = 'file';
        newSceneBackgroundInput.accept = 'image/*,video/*';
        const videoVolumeControls = document.getElementById('video-volume-controls');
        const videoVolumeSlider = document.getElementById('video-volume-slider');
        const videoVolumeBtn = document.getElementById('video-volume-btn');
        const recordingCanvas = document.createElement('canvas');
        const recordingCtx = recordingCanvas.getContext('2d');
        const previewBtn = document.getElementById('mg-preview-btn');
        const previewSceneBtn = document.getElementById('mg-preview-scene-btn');
        const previewPopup = document.getElementById('mg-preview-popup');
        const previewVideo = document.getElementById('mg-preview-video');
        const generateProjectBtn = document.getElementById('mg-generate-project-btn');
        const generationOverlay = document.getElementById('mg-generation-overlay');
        const postGenerationActions = document.getElementById('post-generation-actions');
        const deleteSceneBtn = document.getElementById('mg-delete-scene-btn');
        const confirmationOverlay = document.getElementById('mg-confirmation-overlay');
        const confirmationText = document.getElementById('mg-confirmation-text');
        const confirmYesBtn = document.getElementById('mg-confirm-yes-btn');
        const confirmNoBtn = document.getElementById('mg-confirm-no-btn');
        const shortcutsBtn = document.getElementById('shortcuts-btn');
        const shortcutsDropdown = document.getElementById('shortcuts-dropdown');
        const visualsBtn = document.getElementById('visuals-btn');
        const visualsDropdown = document.getElementById('visuals-dropdown');
        const assetVisualsControls = document.getElementById('asset-visuals-controls');
        const assetOpacitySlider = document.getElementById('asset-opacity');
        const assetBrightnessSlider = document.getElementById('asset-brightness');
        const assetSaturationSlider = document.getElementById('asset-saturation');
        const bgBrightnessSlider = document.getElementById('bg-brightness');
        const bgSaturationSlider = document.getElementById('bg-saturation');
        const audioBtn = document.getElementById('audio-btn');
        const audioDropdown = document.getElementById('audio-dropdown');
        const audioControls = document.getElementById('audio-controls');
        const sceneAudioInput = document.getElementById('scene-audio-input');
        const removeAudioBtn = document.getElementById('remove-audio-btn');
        const audioFileName = document.getElementById('audio-file-name');
        let finalProjectUrl = null;

        // New Text Elements
        const textBtn = document.getElementById('text-btn'); // This is now the main button for text actions
        const textDropdown = document.getElementById('text-dropdown');
        const textVisualsControls = document.getElementById('text-visuals-controls');
        const textContentInput = document.getElementById('text-content');
        const textFontSelect = document.getElementById('text-font');
        const textSizeSlider = document.getElementById('text-size');
        const textColorInput = document.getElementById('text-color');
        const textOpacitySlider = document.getElementById('text-opacity');
        const textBrightnessSlider = document.getElementById('text-brightness');
        const textSaturationSlider = document.getElementById('text-saturation');


        // === State Variables ===
        const DAMPING_FACTOR = 0.5;
        const RESIZE_SPEED = 1.546875;
        const assetCache = {};
        let scenes = [];
        let activeSceneId = null;
        let lastRecordingDurationMs = 0;   // duration of the most recent take
        let activeMovieLayerId = null; // Still one active layer for controls/interaction
        let movieInteraction = { active: false };
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let isCountdownActive = false;
        let layerRecordingUrl = null;
        let animationFrameId = null;
        let recordingIntervalId = null;
        let recordingStartTime = 0;
        let resizeState = { isResizing: false, direction: 0, animationFrameId: null };
        let isDraggingSlider = false;
        let masterWidth = 1280; // Default master dimensions for recording
        let masterHeight = 720; // Will be updated based on background aspect ratio

        const getCurrentScene = () => scenes.find(s => s.id === activeSceneId);
        const getActiveLayer = () => getCurrentScene()?.layers.find(l => l.id === activeMovieLayerId);

        let toastTimeoutId;
        const toast = (msg, duration = 4000) => {
            const t = document.getElementById('mg-toast');
            clearTimeout(toastTimeoutId);
            t.textContent = msg; t.style.opacity = 1; t.style.visibility = 'visible';
            if (duration !== null) {
                toastTimeoutId = setTimeout(() => { t.style.opacity = 0; t.style.visibility = 'hidden'; }, duration);
            }
        };

        // --- Duration helpers ---
        function getMediaDurationMs(el, type) {
          if (type === 'video' && el && !Number.isNaN(el.duration) && el.duration > 0) {
            return Math.floor(el.duration * 1000);
          }
          // default still-image duration
          return 3000;
        }

        // Ensures a scene's duration never shrinks.
        // Pass any candidate duration (ms); it will only increase the stored duration.
        function ensureSceneDurationMs(scene, candidateMs) {
          const cand = Math.max(0, candidateMs || 0);
          const prev = Math.max(0, scene.durationMs || 0);
          scene.durationMs = Math.max(prev, cand);
        }

        // Pads (keeps recording) until `targetMs` since `recordingStartTime`.
        // Calls the provided `finalize` callback when padding is complete.
        function padRecordingUntil(targetMs, finalize) {
          const remaining = targetMs - (Date.now() - recordingStartTime);
          if (remaining <= 0) { finalize(); return; }

          // Keep the animation loop running; we want to keep drawing the last frame.
          // We just wait for the remaining time, then finalize.
          setTimeout(finalize, remaining);
        }
        
        function resetToReadyState() {
            const currentScene = getCurrentScene();
            recordLayerBtn.disabled = !currentScene || currentScene.layers.length === 0;
            recordLayerBtn.textContent = 'Record Layer';
            recordLayerBtn.classList.add('record');
            sceneActionsContainer.classList.remove('hidden');
            stopActionsContainer.classList.add('hidden');
            commitLayerBtn.classList.add('hidden');
            commitLayerBtn.classList.remove('success');

            if (layerRecordingUrl) {
                URL.revokeObjectURL(layerRecordingUrl);
                layerRecordingUrl = null;
            }
            recordedChunks = [];
        }

        function updateProjectControlsState() {
            generateProjectBtn.disabled = scenes.length === 0;
            if (finalProjectUrl) {
                URL.revokeObjectURL(finalProjectUrl);
                finalProjectUrl = null;
            }
            previewBtn.classList.add('hidden');
            movieDownloadBtn.classList.add('hidden');
            postGenerationActions.classList.add('hidden');
        }

        function updateControlsState() {
            const hasScenes = scenes.length > 0;
            const currentScene = getCurrentScene();
            
            const hasImageOrVideoLayer = currentScene?.layers.some(l => l.type === 'image' || l.type === 'video');
            const hasTextLayer = currentScene?.layers.some(l => l.type === 'text');
            const hasAnyLayers = currentScene && currentScene.layers.length > 0;

            addSceneBtn.disabled = isRecording;
            deleteSceneBtn.disabled = !hasScenes || isRecording;
            recordLayerBtn.disabled = !hasAnyLayers || isRecording;
            
            // Update #text-btn state
            textBtn.disabled = !hasScenes || isRecording;
            if (hasTextLayer) {
                textBtn.textContent = "Edit Text";
            } else {
                textBtn.textContent = "+ Add Text Layer";
            }
            
            // Disable 'Add Asset' (palette slot) if an image/video layer exists
            
            // hasPreviewableContent logic from the fix
            const hasPreviewableContent = currentScene && (currentScene.backgroundType === 'video' || !!layerRecordingUrl || (currentScene.durationMs && currentScene.durationMs > 0));
            previewSceneBtn.disabled = !hasPreviewableContent || isRecording;
            
            updateProjectControlsState();
            renderLayerPalette();
        }

        function handleBackgroundUpload(file, mode, isFromLayerCommit = false) {
            if (!file) return;
            const fileURL = (file instanceof Blob) ? URL.createObjectURL(file) : file;

            // Replace the handleNewScene’s inner handleNewScene with this version (only this block):
            const handleNewScene = (element, type, thumb, durMs) => {
              let sceneToUpdate;
              if (isFromLayerCommit) {
                sceneToUpdate = getCurrentScene();
                if (sceneToUpdate) {
                  // Clear active layers as they are now "baked" into the new background
                  sceneToUpdate.layers = [];
                  activeMovieLayerId = null;

                  sceneToUpdate.backgroundElement = element;
                  sceneToUpdate.backgroundType = type;
                  sceneToUpdate.thumbnail = thumb;
                  sceneToUpdate.backgroundHistory.push(element);

                  // IMPORTANT: never shrink duration - Use the helper everywhere you currently assign scene.durationMs
                  const newDur = durMs ?? getMediaDurationMs(element, type);
                  ensureSceneDurationMs(sceneToUpdate, newDur);

                  toast('Layer committed! Add another asset to continue layering.', 4000);
                }
              } else {
                const initialDur = durMs ?? getMediaDurationMs(element, type);
                sceneToUpdate = {
                  id: Date.now(),
                  backgroundElement: element,
                  backgroundType: type,
                  thumbnail: thumb,
                  layers: [],
                  originalBackgroundElement: element,
                  originalBackgroundType: type,
                  originalThumbnail: thumb,
                  committedLayerSrcs: [],
                  backgroundHistory: [element],
                  bgBrightness: 1,
                  bgSaturation: 1,
                  audioElement: null,
                  audioName: null,
                  // NEW: persistent scene duration (never shrinks)
                  durationMs: 0, // temp; set via helper just below
                  audioDurationMs: 0, // Added to store audio duration without affecting scene duration
                };
                scenes.push(sceneToUpdate);
                // Immediately after pushing the scene to scenes (right after the object literal):
                ensureSceneDurationMs(sceneToUpdate, initialDur);

                if (mode === 'initial') {
                  canvasPlaceholder.classList.add('hidden');
                  toast('Background set! Add an asset to start.', 3000);
                }
              }

              requestAnimationFrame(() => {
                switchScene(sceneToUpdate.id);
                updateControlsState();
              });
            };

            if (file.type.startsWith('image/')) {
                const img = new Image();
                // In the image branch of handleBackgroundUpload, pass a duration:
                img.onload = () => handleNewScene(img, 'image', img.src, 3000);
                img.onerror = () => toast('Could not load background image.');
                img.src = fileURL;
            } else if (file.type.startsWith('video/')) {
                const video = document.createElement('video');
                video.loop = !isFromLayerCommit;
                video.autoplay = false; video.muted = true; video.playsinline = true;

                // In the video branch of handleBackgroundUpload, compute and pass the duration:
                let durMs = 0;

                const onSeeked = () => {
                    video.removeEventListener('seeked', onSeeked, false);
                    const thumbCanvas = document.createElement('canvas');
                    thumbCanvas.width = video.videoWidth;
                    thumbCanvas.height = video.videoHeight;
                    thumbCanvas.getContext('2d').drawImage(video, 0, 0);
                    handleNewScene(video, 'video', thumbCanvas.toDataURL('image/jpeg'), durMs);
                    video.currentTime = 0;
                    video.muted = false;
                    video.volume = videoVolumeSlider.value;
                };
                const onLoaded = () => {
                    video.removeEventListener('loadedmetadata', onLoaded, false);
                    durMs = getMediaDurationMs(video, 'video');
                    video.currentTime = 0.1; 
                };

                video.addEventListener('loadedmetadata', onLoaded, false);
                video.addEventListener('seeked', onSeeked, false);
                video.onerror = () => toast('Could not load background video.');
                video.src = fileURL;
            } else {
                toast('Unsupported file type. Please use an image or video.');
            }
        }

        function renderSceneTray() {
            sceneTray.innerHTML = '';
            scenes.forEach((scene, index) => {
                const thumb = document.createElement('div');
                thumb.className = 'scene-thumb';
                thumb.style.backgroundImage = `url(${scene.thumbnail})`;
                thumb.classList.toggle('active', scene.id === activeSceneId);
                thumb.innerHTML = `<span>${index + 1}</span>`;
                if (scenes.length > 0) {
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'scene-delete-btn'; deleteBtn.innerHTML = 'x';
                    deleteBtn.onclick = (e) => { e.stopPropagation(); deleteScene(scene.id); };
                    thumb.appendChild(deleteBtn);
                }
                thumb.onclick = () => { if (scene.id !== activeSceneId && !isRecording) switchScene(scene.id); };
                sceneTray.appendChild(thumb);
            });
        }
        
        function resizeCanvas() {
            const currentScene = getCurrentScene();
            if (!currentScene) return;

            const panelWidth = canvasPanel.clientWidth;
            const panelHeight = canvasPanel.clientHeight;
            if (panelWidth === 0 || panelHeight === 0) return;

            const canvasAspectRatio = movieCanvas.width / movieCanvas.height;
            let displayWidth, displayHeight;

            if (panelWidth / panelHeight > canvasAspectRatio) {
                displayHeight = panelHeight;
                displayWidth = displayHeight * canvasAspectRatio;
            } else {
                displayWidth = panelWidth;
                displayHeight = displayWidth / canvasAspectRatio;
            }

            [movieCanvas, controlsOverlayCanvas].forEach(c => {
                c.style.width = `${displayWidth}px`;
                c.style.height = `${displayHeight}px`;
            });
        }


        function switchScene(sceneId) {
            stopAnimationLoop();
            activeSceneId = sceneId;
            const currentScene = getCurrentScene(); if (!currentScene) return;
            activeMovieLayerId = null; // Reset active layer on scene switch

            const bg = currentScene.backgroundElement;
            const w = bg.naturalWidth || bg.videoWidth;
            const h = bg.naturalHeight || bg.videoHeight;
            
            let aspectRatio = w / h;
            if (!isFinite(aspectRatio) || aspectRatio === 0) {
                aspectRatio = 16 / 9;
            }

            const qualityWidth = 1280;
            movieCanvas.width = controlsOverlayCanvas.width = qualityWidth;
            movieCanvas.height = controlsOverlayCanvas.height = qualityWidth / aspectRatio;
            
            // Set master dimensions for recording based on the current scene's background
            masterWidth = movieCanvas.width;
            masterHeight = movieCanvas.height;


            resizeCanvas();

            if (currentScene.backgroundType === 'video') {
                videoVolumeControls.classList.remove('hidden');
                currentScene.backgroundElement.volume = videoVolumeSlider.value;
            } else {
                videoVolumeControls.classList.add('hidden');
                videoVolumeControls.classList.remove('open');
            }

            renderSceneTray();
            renderLayerPalette();
            drawControlsOverlay();
            resetToReadyState();
            updateControlsState();
            updateEditPanelsUI(); // Update all panel UIs
            updateAudioUI();
            startAnimationLoop();
        }

        function deleteScene(sceneIdToDelete) {
            if (scenes.length === 0) return;
            const sceneIndex = scenes.findIndex(s => s.id === sceneIdToDelete);
            
            if (scenes.length === 1) {
                clearProject();
                return;
            }

            scenes.splice(sceneIndex, 1);
            if (activeSceneId === sceneIdToDelete) {
                const newActiveIndex = Math.max(0, sceneIndex - 1);
                switchScene(scenes[newActiveIndex].id);
            } else {
                renderSceneTray();
            }
            updateControlsState();
        }

        function populateAssetLibraryGrid() {
            document.getElementById('mg-asset-picker-grid').innerHTML = '';
            const addAssetFromLibrary = (src) => {
                const currentScene = getCurrentScene();
                if(!currentScene) { toast('Please add a background to the scene first.', 2000); return; }
                const hasImageOrVideoLayer = currentScene.layers.some(l => l.type === 'image' || l.type === 'video');
                if(hasImageOrVideoLayer) { toast('Only one image or video asset can be animated at a time. Delete the existing one first.', 4000); return; }

                addMovieLayer(src, { type: 'image' });
                closeAssetLibrary();
            };
            Array.from({length: 107}, (_, i) => i + 1).forEach(i => {
                const src = `./assets/maker/${i}.png`;
                const div = document.createElement('div');
                div.className = 'mg-template';
                div.innerHTML = `<img src="${src}" alt="Asset ${i}">`;
                div.addEventListener('click', () => addAssetFromLibrary(src));
                document.getElementById('mg-asset-picker-grid').appendChild(div);
            });
        }

        function openAssetLibrary() {
            populateAssetLibraryGrid();
            assetLibraryOverlay.classList.add('visible');
        }
        function closeAssetLibrary() { assetLibraryOverlay.classList.remove('visible'); }
        
        function updateLayerInstructions() {
            const currentScene = getCurrentScene();
            layerInstructions.classList.remove('placeholder-text');

            if (!currentScene) {
                layerInstructions.textContent = "Create a scene to begin.";
                layerInstructions.classList.add('placeholder-text');
                return;
            }
            
            const hasImageOrVideoLayer = currentScene.layers.some(l => l.type === 'image' || l.type === 'video');
            const hasTextLayer = currentScene.layers.some(l => l.type === 'text');
            const hasCommittedLayers = currentScene.committedLayerSrcs.length > 0;

            if (hasImageOrVideoLayer || hasTextLayer) {
                layerInstructions.textContent = "Click 'Record Layer' to animate the active asset(s), then 'Stop'.";
            } else if (hasCommittedLayers) {
                 layerInstructions.textContent = "Add another asset (image, video, or text) to continue layering on this scene.";
            } else {
                 layerInstructions.textContent = "Add an asset (image, video, or text), click 'Record Layer' to animate it, then 'Stop'. Then use the 'Commit Layer' button to continue animating your scene.";
            }
        }

        function renderLayerPalette() {
            assetPalette.innerHTML = '';
            updateLayerInstructions();

            const currentScene = getCurrentScene();
            if (!currentScene) {
                // The textBtn is now handled in updateControlsState()
                return;
            };

            const hasImageOrVideoLayer = currentScene.layers.some(l => l.type === 'image' || l.type === 'video');
            // The textBtn is now handled in updateControlsState()


            currentScene.committedLayerSrcs.forEach((src, index) => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb locked';
                thumb.title = "This layer is committed. Click X to revert.";
                // Committed layers are always image snapshots, so we can use <img>
                thumb.innerHTML = `<img src="${src}"><div class="layer-controls"><div class="layer-btn delete" title="Delete this committed layer and subsequent layers">x</div></div>`;
                thumb.querySelector('.delete').onclick = (e) => { e.stopPropagation(); deleteCommittedLayer(index); };
                assetPalette.appendChild(thumb);
            });

            // Display active layers (image/video and text)
            currentScene.layers.forEach(activeLayer => {
                 const thumb = document.createElement('div');
                 thumb.className = 'layer-thumb';
                 thumb.classList.toggle('active', activeLayer.id === activeMovieLayerId);
                 thumb.dataset.layerId = activeLayer.id;
                 thumb.title = "Click to select";
                 
                 let thumbContent;
                 if (activeLayer.type === 'video') {
                     thumbContent = `<video src="${activeLayer.src}" muted loop autoplay playsinline></video>`;
                 } else if (activeLayer.type === 'image') {
                     thumbContent = `<img src="${activeLayer.src}">`;
                 } else if (activeLayer.type === 'text') {
                     // For text thumbnail, render text directly with CSS for quick preview
                     thumbContent = `<span style="font-family: ${activeLayer.font}; font-size: 1.2rem; color: ${activeLayer.color}; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding: 2px;">${activeLayer.text}</span>`;
                     thumb.style.backgroundColor = 'var(--ink)'; // Make text visible against light palette
                     thumb.style.display = 'flex';
                     thumb.style.alignItems = 'center';
                     thumb.style.justifyContent = 'center';
                 }
                 thumb.innerHTML = `${thumbContent}<div class="layer-controls"><div class="layer-btn delete" title="Delete Layer">x</div></div>`;

                 thumb.addEventListener('click', (e) => {
                     if (e.target.classList.contains('layer-btn')) return;
                     if (activeMovieLayerId !== activeLayer.id) {
                        activeMovieLayerId = activeLayer.id;
                        renderLayerPalette(); // Rerender to show new active state
                        drawControlsOverlay(); // Redraw controls for new active layer
                        updateEditPanelsUI(); // Update UI panels for new active layer
                     }
                 });
                 thumb.querySelector('.delete').onclick = (e) => { e.stopPropagation(); deleteMovieLayer(activeLayer.id); };
                 assetPalette.appendChild(thumb);
            });

            // Add empty slot for new image/video asset
            if(!hasImageOrVideoLayer && currentScene.committedLayerSrcs.length < 8) { // Max 8 committed layers shown
                const emptySlot = document.createElement('div');
                emptySlot.className = 'palette-slot empty';
                emptySlot.innerHTML = '+';
                emptySlot.title = "Add a new image or video asset";
                emptySlot.onclick = openAssetLibrary;
                assetPalette.appendChild(emptySlot);
            }
        }

        function deleteCommittedLayer(indexToDelete) {
            const scene = getCurrentScene();
            if (!scene) return;

            // Revoke the URL if it's an object URL (from a recorded layer commit)
            if (scene.committedLayerSrcs[indexToDelete].startsWith('blob:')) {
                 URL.revokeObjectURL(scene.committedLayerSrcs[indexToDelete]);
            }
            
            const backgroundToRestore = scene.backgroundHistory[indexToDelete];

            scene.backgroundElement = backgroundToRestore;
            scene.backgroundType = (backgroundToRestore.tagName === 'VIDEO') ? 'video' : 'image';
            
            scene.backgroundHistory.splice(indexToDelete + 1);
            scene.committedLayerSrcs.splice(indexToDelete);

            // When reverting a committed layer (deleteCommittedLayer)
            ensureSceneDurationMs(scene, getMediaDurationMs(scene.backgroundElement, scene.backgroundType));


            let newThumbnail;
            if (backgroundToRestore.tagName === 'VIDEO') {
                const tempVideo = backgroundToRestore.cloneNode(true); // Clone to avoid interfering with current playback
                tempVideo.muted = true;
                tempVideo.autoplay = false;
                tempVideo.playsinline = true;
                const captureThumbnail = () => {
                    const thumbCanvas = document.createElement('canvas');
                    thumbCanvas.width = tempVideo.videoWidth;
                    thumbCanvas.height = tempVideo.videoHeight;
                    thumbCanvas.getContext('2d').drawImage(tempVideo, 0, 0);
                    newThumbnail = thumbCanvas.toDataURL('image/jpeg');
                    tempVideo.removeEventListener('seeked', captureThumbnail);
                    tempVideo.pause();
                    scene.thumbnail = newThumbnail; // Update scene thumbnail
                    switchScene(scene.id);
                    toast('Layer reverted.', 2000);
                };
                tempVideo.addEventListener('seeked', captureThumbnail);
                tempVideo.currentTime = 0.1; // Seek to capture frame
                tempVideo.load(); // Ensure metadata is loaded if not already
            } else { // Image or canvas-generated image (e.g. text snapshot as part of history)
                if (backgroundToRestore.tagName === 'IMG') {
                    newThumbnail = backgroundToRestore.src;
                } else { // Handle data URLs directly
                    newThumbnail = backgroundToRestore.src || backgroundToRestore.toDataURL?.('image/png') || '';
                }
                scene.thumbnail = newThumbnail;
                switchScene(scene.id);
                toast('Layer reverted.', 2000);
            }
        }

        function updateAssetVisualsUI() {
            const activeLayer = getActiveLayer();

            if (activeLayer && (activeLayer.type === 'image' || activeLayer.type === 'video')) {
                assetVisualsControls.classList.remove('disabled');
                assetOpacitySlider.value = activeLayer.opacity;
                assetBrightnessSlider.value = activeLayer.brightness;
                assetSaturationSlider.value = activeLayer.saturation;
            } else {
                assetVisualsControls.classList.add('disabled');
                assetOpacitySlider.value = 1;
                assetBrightnessSlider.value = 1;
                assetSaturationSlider.value = 1;
            }
        }

        function updateTextVisualsUI() {
            const activeLayer = getActiveLayer();

            if (activeLayer && activeLayer.type === 'text') {
                textVisualsControls.classList.remove('disabled');
                textContentInput.value = activeLayer.text;
                textFontSelect.value = activeLayer.font;
                textSizeSlider.value = activeLayer.fontSize;
                textColorInput.value = activeLayer.color;
                textOpacitySlider.value = activeLayer.opacity;
                textBrightnessSlider.value = activeLayer.brightness;
                textSaturationSlider.value = activeLayer.saturation;
            } else {
                textVisualsControls.classList.add('disabled');
                // Reset text sliders visually when no text layer is active
                textContentInput.value = "New Text";
                textFontSelect.value = "Arial, sans-serif";
                textSizeSlider.value = 60;
                textColorInput.value = "#FFFFFF";
                textOpacitySlider.value = 1;
                textBrightnessSlider.value = 1;
                textSaturationSlider.value = 1;
            }
        }

        function updateBackgroundVisualsUI() {
            const currentScene = getCurrentScene();
            bgBrightnessSlider.value = currentScene ? currentScene.bgBrightness : 1;
            bgSaturationSlider.value = currentScene ? currentScene.bgSaturation : 1;
        }

        // Orchestrates updating all visual-related UIs
        function updateEditPanelsUI() {
            updateAssetVisualsUI();
            updateTextVisualsUI();
            updateBackgroundVisualsUI();
        }

        function updateAudioUI() {
            const currentScene = getCurrentScene();
            if (!currentScene) {
                audioControls.classList.add('disabled');
                audioFileName.textContent = "No active scene.";
                removeAudioBtn.disabled = true;
            } else {
                audioControls.classList.remove('disabled');
                if (currentScene.audioName) {
                    audioFileName.textContent = currentScene.audioName;
                    removeAudioBtn.disabled = false;
                } else {
                    audioFileName.textContent = "No audio added.";
                    removeAudioBtn.disabled = true;
                }
            }
        }

        function addMovieLayer(src, properties = {}) {
            const currentScene = getCurrentScene();
            if (!currentScene) { toast('Add a background first.', 2000); return; }

            const assetType = properties.type || 'image';

            const hasImageOrVideoLayer = currentScene.layers.some(l => l.type === 'image' || l.type === 'video');
            if (hasImageOrVideoLayer) { toast('Only one image or video asset can be animated at a time. Delete the existing one first.', 4000); return; }


            const createLayer = (element) => {
                const scene = getCurrentScene();
                if (!scene) return;

                // --- Video setup for seamless native loop (no manual seeking) ---
                if (assetType === 'video') {
                    // Ensure consistent settings even if element came from cache
                    element.preload = 'auto';
                    element.muted = true;
                    element.playsinline = true;
                    element.loop = true;

                    // Prime slightly off zero to avoid iOS/WebKit stalls/black at exact 0.0
                    const prime = () => {
                        try { element.currentTime = 0.001; } catch {}
                        element.play().catch(() => {});
                    };

                    if (element.readyState >= 2) {
                        prime();
                    } else {
                        element.addEventListener('loadeddata', prime, { once: true });
                    }
                }
                // --- end video setup ---

                const newLayer = {
                    id: Date.now() + Math.random(),
                    src,
                    asset: element, // For image/video
                    type: assetType,
                    x: properties.x || movieCanvas.width / 2,
                    y: properties.y || movieCanvas.height / 2,
                    size: properties.size || movieCanvas.width * 0.25, // For image/video width
                    rot: properties.rot || 0,
                    flipX: false,
                    opacity: 1,
                    brightness: 1,
                    saturation: 1,
                };

                scene.layers.push(newLayer);
                activeMovieLayerId = newLayer.id;

                renderLayerPalette();
                updateControlsState();
                updateEditPanelsUI();
                drawMovieFrame();
                drawControlsOverlay();
                toast('Asset Added! Ready to record.', 3000);
            };

            // If we already cached this asset, reuse it (and re-prime if video)
            if (assetCache[src]) {
                const cached = assetCache[src];
                if (assetType === 'video') {
                    // Reapply loop/prime in case this element was paused or at end
                    cached.preload = 'auto';
                    cached.muted = true;
                    cached.playsinline = true;
                    cached.loop = true;
                    try { cached.currentTime = 0.001; } catch {}
                    cached.play().catch(() => {});
                }
                createLayer(cached);
                return;
            }

            if (assetType === 'image') {
                const image = new Image();
                image.onload = () => { assetCache[src] = image; createLayer(image); };
                image.onerror = () => toast(`Could not load asset: ${src}`);
                image.src = src;
            } else if (assetType === 'video') {
                const video = document.createElement('video');
                // Do NOT set src first; set attributes first for consistency
                video.preload = 'auto';
                video.muted = true;
                video.playsinline = true;
                video.loop = true;

                const onLoaded = () => {
                    assetCache[src] = video;
                    createLayer(video);
                };
                video.addEventListener('loadeddata', onLoaded, { once: true });
                video.onerror = () => toast(`Could not load video asset: ${src}`);
                video.src = src;
            }
        }

        // Function to add text layers
                // Function to add text layers
        function addTextLayer() {
            const currentScene = getCurrentScene();
            if (!currentScene) { toast('Add a background first.', 2000); return; }
            
            const hasTextLayer = currentScene.layers.some(l => l.type === 'text');
            if (hasTextLayer) { toast('Only one text layer can be animated at a time. Delete the existing one first.', 4000); return; }

            const newTextLayer = {
                id: Date.now() + Math.random(),
                type: 'text',
                text: 'New Text',
                font: "Arial, sans-serif", // Default font
                fontSize: 100,             // (or whatever size you want)
                color: '#FFFFFF', // Default color
                x: movieCanvas.width / 2,
                y: movieCanvas.height / 2,
                rot: 0,
                flipX: false,
                opacity: 1,
                brightness: 1,
                saturation: 1,
                width: 0, // Will be dynamically calculated during draw
                height: 0, // Will be dynamically calculated during draw
            };
            currentScene.layers.push(newTextLayer);
            activeMovieLayerId = newTextLayer.id;

            renderLayerPalette();
            updateControlsState();
            updateEditPanelsUI();
            drawMovieFrame();
            drawControlsOverlay();
            toast('Text layer added! Ready to record.', 3000);

            // NEW: Automatically open the text dropdown and focus the input
            textDropdown.classList.add('visible');
            textContentInput.focus();
        }

        function deleteMovieLayer(layerId) {
            const currentScene = getCurrentScene(); if (!currentScene) return;
            const layer = currentScene.layers.find(l => l.id === layerId);
            if (layer && layer.type === 'video') {
                layer.asset.pause();
            }
            currentScene.layers = currentScene.layers.filter(l => l.id !== layerId);
            if (activeMovieLayerId === layerId) activeMovieLayerId = null;
            renderLayerPalette();
            updateControlsState();
            updateEditPanelsUI(); // Update UI for changes
            drawMovieFrame();
            drawControlsOverlay();
        }
        
        function drawMovieFrame() {
            const currentScene = getCurrentScene();
            if (!currentScene || !currentScene.backgroundElement) {
                movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
                return;
            }

            // Damping for active layer drag interaction
            const activeLayerForInteraction = getActiveLayer();
            if (movieInteraction.active && movieInteraction.type === 'drag' && !movieInteraction.primed && activeLayerForInteraction) {
                const dx = movieInteraction.targetX - activeLayerForInteraction.x;
                const dy = movieInteraction.targetY - activeLayerForInteraction.y;
                if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                    activeLayerForInteraction.x += dx * DAMPING_FACTOR;
                    activeLayerForInteraction.y += dy * DAMPING_FACTOR;
                } else {
                    activeLayerForInteraction.x = movieInteraction.targetX;
                    activeLayerForInteraction.y = movieInteraction.targetY;
                }
            }

            const { backgroundElement, layers: movieLayers, bgBrightness, bgSaturation } = currentScene;

            movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
            movieCtx.save();
            movieCtx.filter = `brightness(${bgBrightness}) saturate(${bgSaturation})`;
            movieCtx.drawImage(backgroundElement, 0, 0, movieCanvas.width, movieCanvas.height);
            movieCtx.restore();

            movieLayers.forEach(l => {
                movieCtx.save();
                movieCtx.globalAlpha = l.opacity;
                movieCtx.filter = `brightness(${l.brightness}) saturate(${l.saturation})`;
                movieCtx.translate(l.x, l.y);
                movieCtx.rotate(l.rot * Math.PI / 180);
                if (l.flipX) {
                    movieCtx.scale(-1, 1);
                }

                if (l.type === 'image' || l.type === 'video') {
                    const isReady = (l.type === 'image' && l.asset.complete) || (l.type === 'video' && l.asset.readyState > 1);
                    if (l.asset && isReady) {
                        const assetWidth = l.type === 'image' ? l.asset.naturalWidth : l.asset.videoWidth;
                        const assetHeight = l.type === 'image' ? l.asset.naturalHeight : l.asset.videoHeight;
                        if (assetWidth === 0) { movieCtx.restore(); return; }

                        const dWidth = l.size;
                        const dHeight = l.size * (assetHeight / assetWidth);
                        movieCtx.drawImage(l.asset, -dWidth / 2, -dHeight / 2, dWidth, dHeight);
                    }
                } else if (l.type === 'text') {
                    movieCtx.font = `${l.fontSize}px ${l.font}`;
                    movieCtx.fillStyle = l.color;
                    movieCtx.textAlign = 'center';
                    movieCtx.textBaseline = 'middle';

                    // Measure text for accurate width/height for interaction bounding box
                    const textMetrics = movieCtx.measureText(l.text);
                    l.width = textMetrics.width;
                    l.height = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 4; // Add a small padding
                    
                    movieCtx.fillText(l.text, 0, 0);
                }
                movieCtx.restore();
            });


            if (isRecording) {
                const bg = backgroundElement;
                if(masterWidth === 0 || masterHeight === 0) return; // Ensure master dimensions are set

                recordingCanvas.width = masterWidth;
                recordingCanvas.height = masterHeight;

                recordingCtx.clearRect(0, 0, recordingCanvas.width, recordingCanvas.height);
                
                recordingCtx.save();
                recordingCtx.filter = `brightness(${bgBrightness}) saturate(${bgSaturation})`;
                recordingCtx.drawImage(bg, 0, 0, recordingCanvas.width, recordingCanvas.height); // Draw background at master size
                recordingCtx.restore();

                const previewCanvasWidth = movieCanvas.width; // Original movie canvas dimensions (for scaling layers)
                const previewCanvasHeight = movieCanvas.height;
                movieLayers.forEach(l => {
                    recordingCtx.save();
                    recordingCtx.globalAlpha = l.opacity;
                    recordingCtx.filter = `brightness(${l.brightness}) saturate(${l.saturation})`;
                    
                    // Scale layer position and size from current canvas to recording canvas
                    const scaleX = recordingCanvas.width / previewCanvasWidth;
                    const scaleY = recordingCanvas.height / previewCanvasHeight;

                    const finalX = l.x * scaleX;
                    const finalY = l.y * scaleY;

                    recordingCtx.translate(finalX, finalY);
                    recordingCtx.rotate(l.rot * Math.PI / 180);
                    if (l.flipX) {
                        recordingCtx.scale(-1, 1);
                    }

                    if (l.type === 'image' || l.type === 'video') {
                        const isReady = (l.type === 'image' && l.asset.complete) || (l.type === 'video' && l.asset.readyState > 1);
                        if (l.asset && isReady) {
                            const assetWidth = l.type === 'image' ? l.asset.naturalWidth : l.asset.videoWidth;
                            const assetHeight = l.type === 'image' ? l.asset.naturalHeight : l.asset.videoHeight;
                            if (assetWidth === 0) { recordingCtx.restore(); return; }

                            const scaledSize = l.size * scaleX; // l.size is width
                            const dWidth = scaledSize;
                            const dHeight = scaledSize * (assetHeight / assetWidth);
                            recordingCtx.drawImage(l.asset, -dWidth / 2, -dHeight / 2, dWidth, dHeight);
                        }
                    } else if (l.type === 'text') {
                        // Scale font size for recording canvas
                        const finalFontSize = l.fontSize * scaleY; // Scale font size based on Y-scale
                        recordingCtx.font = `${finalFontSize}px ${l.font}`;
                        recordingCtx.fillStyle = l.color;
                        recordingCtx.textAlign = 'center';
                        recordingCtx.textBaseline = 'middle';
                        recordingCtx.fillText(l.text, 0, 0);
                    }
                    recordingCtx.restore();
                });
            }
        }


        function drawControlsOverlay() {
            controlsCtx.clearRect(0, 0, controlsOverlayCanvas.width, controlsOverlayCanvas.height);
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                let dWidth, dHeight;

                if (activeLayer.type === 'image' || activeLayer.type === 'video') {
                    const assetWidth = activeLayer.type === 'image' ? activeLayer.asset.naturalWidth : activeLayer.asset.videoWidth;
                    const assetHeight = activeLayer.type === 'image' ? activeLayer.asset.naturalHeight : activeLayer.asset.videoHeight;
                    if (assetWidth === 0) return;
                    dWidth = activeLayer.size; // `size` represents width for image/video
                    dHeight = activeLayer.size * (assetHeight / assetWidth);
                } else if (activeLayer.type === 'text') {
                    // These should have been calculated during the last drawMovieFrame
                    if (!activeLayer.width || !activeLayer.height || activeLayer.width === 0) {
                        controlsCtx.font = `${activeLayer.fontSize}px ${activeLayer.font}`;
                        const textMetrics = controlsCtx.measureText(activeLayer.text);
                        activeLayer.width = textMetrics.width;
                        activeLayer.height = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 4;
                    }
                    dWidth = activeLayer.width;
                    dHeight = activeLayer.height;
                } else {
                    return; // Unknown layer type
                }
                
                const HANDLE_SIZE = 16;
                const ho = HANDLE_SIZE / 2; const ROTATION_HANDLE_OFFSET = 30;
                controlsCtx.save();
                controlsCtx.translate(activeLayer.x, activeLayer.y);
                controlsCtx.rotate(activeLayer.rot * Math.PI / 180);
                controlsCtx.strokeStyle = '#00FF00'; controlsCtx.lineWidth = 2;
                controlsCtx.strokeRect(-dWidth / 2, -dHeight / 2, dWidth, dHeight);
                controlsCtx.fillStyle = '#00FF00';
                controlsCtx.fillRect(-dWidth/2-ho, -dHeight/2-ho, HANDLE_SIZE, HANDLE_SIZE);
                controlsCtx.fillRect(dWidth/2-ho, -dHeight/2-ho, HANDLE_SIZE, HANDLE_SIZE);
                controlsCtx.fillRect(-dWidth/2-ho, dHeight/2-ho, HANDLE_SIZE, HANDLE_SIZE);
                controlsCtx.fillRect(dWidth/2-ho, dHeight/2-ho, HANDLE_SIZE, HANDLE_SIZE);
                
                // Rotation handle math clean, correct version - FIX
                const rotHandleY = -dHeight / 2 - ROTATION_HANDLE_OFFSET;
                // rotate (0, rotHandleY) by l.rot around layer center and translate to world:
                const rotatedRotHandleX = (0 * Math.cos(activeLayer.rot * Math.PI / 180) - rotHandleY * Math.sin(activeLayer.rot * Math.PI / 180));
                const rotatedRotHandleY = (0 * Math.sin(activeLayer.rot * Math.PI / 180) + rotHandleY * Math.cos(activeLayer.rot * Math.PI / 180));

                controlsCtx.beginPath(); controlsCtx.moveTo(0, -dHeight / 2);
                controlsCtx.lineTo(0, -dHeight / 2 - ROTATION_HANDLE_OFFSET);
                controlsCtx.stroke(); controlsCtx.beginPath();
                controlsCtx.arc(rotatedRotHandleX, rotatedRotHandleY, HANDLE_SIZE / 2, 0, 2 * Math.PI); // Use rotated coords
                controlsCtx.fill(); controlsCtx.restore();
            }
        }

        function animationLoop() {
            drawMovieFrame();
            drawControlsOverlay();
            animationFrameId = requestAnimationFrame(animationLoop);
        }
        function startAnimationLoop() { if (!animationFrameId) animationLoop(); }
        function stopAnimationLoop() { cancelAnimationFrame(animationFrameId); animationFrameId = null; }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            recordingTimer.textContent = `${String(Math.floor(elapsed/60)).padStart(2,'0')}:${String(elapsed%60).padStart(2,'0')}`;
        }

        function runCountdown(onComplete) {
            isCountdownActive = true;
            let count = 3;
            countdownSpan.textContent = count;
            countdownOverlay.classList.remove('hidden');
            const intervalId = setInterval(() => {
                count--;
                if (count > 0) { countdownSpan.textContent = count; }
                else { 
                    clearInterval(intervalId); 
                    countdownOverlay.classList.add('hidden');
                    isCountdownActive = false;
                    if (movieInteraction.active && movieInteraction.primed) {
                        movieInteraction.primed = false; 
                    }
                    onComplete(); 
                }
            }, 1000);
        }

        function startMovieRecording() {
            const currentScene = getCurrentScene();
            if (!currentScene || currentScene.layers.length === 0) {
                 toast('Please add an asset to the scene first.', 2000);
                 return;
            }
            
            resetToReadyState(); 

            // masterWidth and masterHeight are already set in switchScene based on background
            recordingCanvas.width = masterWidth;
            recordingCanvas.height = masterHeight;

            sceneActionsContainer.classList.add('hidden');
            stopActionsContainer.classList.remove('hidden');
            recordingStatus.classList.remove('hidden');
            updateControlsState();
            startAnimationLoop();
            
            runCountdown(() => {
                // Snapshot longest *visual* duration at the start of this take
                const baselineVisualMs = currentScene.durationMs || 0;
                currentScene._padBaselineMs = baselineVisualMs;

                isRecording = true;
                if (movieInteraction.active && movieInteraction.primed) {
                    movieInteraction.primed = false;
                }
                recordingStartTime = Date.now();
                recordingIntervalId = setInterval(updateTimer, 1000);
                
                const canvasStream = recordingCanvas.captureStream(30);
                
                const audioSourceElement = currentScene.audioElement || (currentScene.backgroundType === 'video' ? currentScene.backgroundElement : null);
                if (audioSourceElement) {
                    audioSourceElement.currentTime = 0;
                    if (audioSourceElement.tagName === 'VIDEO') {
                        audioSourceElement.volume = videoVolumeSlider.value;
                    }
                    let audioStream;
                    if (audioSourceElement.captureStream) audioStream = audioSourceElement.captureStream();
                    else if (audioSourceElement.mozCaptureStream) audioStream = audioSourceElement.mozCaptureStream();
                    
                    if (audioStream && audioStream.getAudioTracks().length > 0) {
                        canvasStream.addTrack(audioStream.getAudioTracks()[0]);
                    }
                }
                
                const hasAudio = canvasStream.getAudioTracks().length > 0;
                const videoBitsPerSecond = 2500000;
                let mimeType = hasAudio ? 'video/webm; codecs=vp9,opus' : 'video/webm; codecs=vp9';
                let blobFileType = 'video/webm';
                
                const mp4MimeType = hasAudio ? 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"' : 'video/mp4; codecs="avc1.42E01E"';
                if(MediaRecorder.isTypeSupported(mp4MimeType)){
                    mimeType = mp4MimeType;
                    blobFileType = 'video/mp4';
                }

                mediaRecorder = new MediaRecorder(canvasStream, { mimeType, videoBitsPerSecond });

                mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: blobFileType });
                    layerRecordingUrl = URL.createObjectURL(blob);
                    commitLayerBtn.classList.remove('hidden');
                    commitLayerBtn.classList.add('success');
                    updateControlsState();
                };
                mediaRecorder.start();

                if (currentScene && currentScene.backgroundType === 'video') {
                    currentScene.backgroundElement.play();
                }
                if (currentScene.audioElement) {
                    currentScene.audioElement.play();
                }
                toast('Recording started!', 2000);
            });
        }
        
        // Replace your entire stopMovieRecording() with this padded version
        function stopMovieRecording() {
            // Do NOT immediately pause/stop anything; we may need to pad.
            const currentScene = getCurrentScene();
            if (!currentScene) return;

            // UI changes right away
            stopActionsContainer.classList.add('hidden');
            recordingTimer.textContent = 'Finalizing...';
            toast('Finalizing recording...', null);

            // Compute durations
            const elapsedMs = Date.now() - recordingStartTime;
            // Pad only to visuals baseline, never to audio
            const baseline = currentScene._padBaselineMs || 0;
            const targetMs = Math.max(baseline, Math.max(500, elapsedMs));

            // Keep isRecording = true until we actually finish & stop the MediaRecorder
            // so the drawing path continues writing frames into recordingCanvas.
            const finalizeStop = () => {
                // Now it's safe to pause media elements (they continued during padding)
                if (currentScene.backgroundType === 'video') {
                    currentScene.backgroundElement.pause();
                    currentScene.backgroundElement.currentTime = 0;
                }
                if (currentScene.audioElement) {
                    currentScene.audioElement.pause();
                    currentScene.audioElement.currentTime = 0;
                    currentScene.audioElement.loop = false;
                }

                if (mediaRecorder?.state !== 'inactive') {
                    mediaRecorder.stop();
                }

                lastRecordingDurationMs = targetMs; // store padded length
                isRecording = false;
                // Add cleanup here, after recording officially stops
                delete currentScene._padBaselineMs;


                sceneActionsContainer.classList.remove('hidden');
                recordLayerBtn.textContent = 'Re-record Layer';
                recordLayerBtn.classList.remove('record');
                recordingStatus.classList.add('hidden');

                clearInterval(recordingIntervalId);
                recordingTimer.textContent = '00:00';

                toast('Layer recorded successfully! Commit it to add another layer.', 4000);
                updateControlsState();
            };

            // If user’s take is already >= target, finalize immediately.
            // Otherwise, keep recording a freeze frame until target.
            if (elapsedMs >= targetMs) {
                finalizeStop();
            } else {
                // DO NOT pause background/audio yet; let them continue so we keep producing frames.
                // If you prefer a literal "freeze frame" with no video motion, uncomment next lines:
                // if (currentScene.backgroundType === 'video') currentScene.backgroundElement.pause();
                // if (currentScene.audioElement) currentScene.audioElement.pause();

                padRecordingUntil(targetMs, finalizeStop);
            }
        }

        function previewCurrentScene() {
            if (isRecording) return;
            const currentScene = getCurrentScene();
            if (!currentScene) {
                toast('No active scene to preview.', 2000);
                return;
            }

            // Normalize: if we somehow have a brand-new video bg that reports longer,
            // lock it in without ever shrinking.
            const intrinsicMs =
              currentScene.backgroundType === 'video'
                ? getMediaDurationMs(currentScene.backgroundElement, 'video')
                : currentScene.durationMs || 0;
            ensureSceneDurationMs(currentScene, intrinsicMs);

            // Target preview length:
            // - Prefer the longest committed duration (durationMs)
            // - If user just recorded but hasn't committed yet, fall back to lastRecordingDurationMs
            // - Always enforce a small floor so the preview actually shows
            const targetMs = Math.max(
                currentScene.durationMs || 0,
                layerRecordingUrl ? lastRecordingDurationMs : 0,
                1000
            );

            let previewUrl = null;
            let videoElementToPlay = null;

            if (layerRecordingUrl) {
                // If there's a fresh take not yet committed, preview that
                previewUrl = layerRecordingUrl;
            } else if (currentScene.backgroundType === 'video') {
                // Otherwise, use the current background
                videoElementToPlay = currentScene.backgroundElement;
            }

            // We loop the source but stop the preview after targetMs to match "longest take wins"
            if (previewUrl) {
                previewVideo.src = previewUrl;
                previewVideo.currentTime = 0;
                previewVideo.loop = true; // Important: loop shorter sources to fill targetMs
                previewPopup.classList.add('visible');

                previewVideo.play().then(() => {
                    setTimeout(() => {
                        previewVideo.pause();
                        previewPopup.classList.remove('visible'); // optional
                    }, targetMs);
                }).catch(() => {});
            } else if (videoElementToPlay) {
                // Use the element's source; loop to fill targetMs
                previewVideo.src = videoElementToPlay.src;
                previewVideo.currentTime = 0;
                previewVideo.loop = true; // Make preview loop (so shorter background clips don’t “feel” truncated)
                previewPopup.classList.add('visible');

                previewVideo.play().then(() => {
                    setTimeout(() => {
                        previewVideo.pause();
                        previewPopup.classList.remove('visible'); // optional
                    }, targetMs);
                }).catch(() => {});
            } else {
                // Static image background: open the popup briefly to match targetMs
                previewVideo.removeAttribute('src');
                previewPopup.classList.add('visible');
                setTimeout(() => {
                    previewPopup.classList.remove('visible');
                }, targetMs);
            }
        }
        
        async function generateFinalMovie() {
            // Guard generateFinalMovie() if scenes.length === 0
            if (scenes.length === 0) {
                toast('Please create at least one scene to generate a project.', 3000);
                return;
            }

            if(isRecording) {
                toast('Please stop the current recording before generating.', 3000);
                return;
            }
            generationOverlay.classList.add('visible');
            const finalChunks = [];
            
            // Re-fetch masterWidth/Height from the first scene's background or default
            masterWidth = scenes[0].backgroundElement.naturalWidth || scenes[0].backgroundElement.videoWidth || 1280;
            masterHeight = scenes[0].backgroundElement.naturalHeight || scenes[0].backgroundElement.videoHeight || 720;
            
            recordingCanvas.width = masterWidth;
            recordingCanvas.height = masterHeight;

            // 1. Create a central AudioContext and a destination for our final audio stream.
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const destinationNode = audioContext.createMediaStreamDestination();
            
            const finalStream = recordingCanvas.captureStream(30);
            const hasAudio = scenes.some(s => s.backgroundType === 'video' || s.audioElement);
            
            // 2. If there's any audio, add the track from our Web Audio destination to the final stream.
            if (hasAudio) {
                finalStream.addTrack(destinationNode.stream.getAudioTracks()[0]);
            }
            
            const videoBitsPerSecond = 8000000;
            let mimeType = hasAudio ? 'video/webm; codecs=vp9,opus' : 'video/webm; codecs=vp9';
            let finalFileType = 'video/webm';
            
            const mp4MimeType = hasAudio ? 'video/mp4; codecs="avc1.42E01E, mp4a.40.2"' : 'video/mp4; codecs="avc1.42E01E"';
            if (MediaRecorder.isTypeSupported(mp4MimeType)) {
                mimeType = mp4MimeType;
                finalFileType = 'video/mp4';
                toast('Exporting to high-quality MP4.', 2000);
            } else {
                toast('MP4 not supported, falling back to WebM.', 3000);
            }
            
            const finalRecorder = new MediaRecorder(finalStream, { mimeType, videoBitsPerSecond });
            
            finalRecorder.ondataavailable = e => { if (e.data.size > 0) finalChunks.push(e.data); };

            const generationPromise = new Promise(resolve => {
                finalRecorder.onstop = () => {
                    const finalBlob = new Blob(finalChunks, { type: finalFileType });
                    finalProjectUrl = URL.createObjectURL(finalBlob);
                    movieDownloadBtn.dataset.filetype = finalFileType;
                    generationOverlay.classList.remove('visible');
                    toast('Project generation complete! You can now preview or download.', 4000);
                    previewBtn.classList.remove('hidden');
                    movieDownloadBtn.classList.remove('hidden');
                    postGenerationActions.classList.remove('hidden');

                    controlsPanel.scrollTo({
                        top: controlsPanel.scrollHeight,
                        behavior: 'smooth'
                    });
                    
                    // 6. Close the audio context to free up resources.
                    audioContext.close();

                    resolve();
                };
            });

            finalRecorder.start();
            
            const renderSceneFrameForGeneration = (scene) => {
                // IMPORTANT: This function draws to `recordingCtx` which has `masterWidth/Height`
                recordingCtx.clearRect(0, 0, masterWidth, masterHeight);
                recordingCtx.save();
                recordingCtx.filter = `brightness(${scene.bgBrightness}) saturate(${scene.bgSaturation})`;
                recordingCtx.drawImage(scene.backgroundElement, 0, 0, masterWidth, masterHeight);
                recordingCtx.restore();
            }

            for (const scene of scenes) {
                // In generateFinalMovie(), enforce the same normalization per scene before you compute sceneDur:
                // visuals-only baseline
                const mediaMs = (scene.backgroundType === 'video')
                  ? getMediaDurationMs(scene.backgroundElement, 'video')
                  : getMediaDurationMs(scene.backgroundElement, 'image');
                ensureSceneDurationMs(scene, mediaMs);

                // sceneDur is always visual-based
                const sceneDur = Math.max(scene.durationMs || 0, 1000);

                // A) For video background scenes: replace the whole video branch with the time-driven loop below
                if (scene.backgroundType === 'video') {
                  await new Promise(sceneResolve => {
                    const bg = scene.backgroundElement;
                    // const sceneDur = Math.max(scene.durationMs || 0, 1000); // This line moved above
                    const startTs = performance.now();

                    // Audio wiring (existing code)
                    let audioSourceNode = null;
                    let videoAudioSourceNode = null;
                    const hasMp3 = !!scene.audioElement;

                    // ensure loop for long scenes
                    bg.loop = true;
                    bg.muted = hasMp3; // if separate mp3, mute bg video audio

                    // (Re)connect audio to central destination
                    if (hasMp3) {
                      audioSourceNode = audioContext.createMediaElementSource(scene.audioElement);
                      audioSourceNode.connect(destinationNode);
                      scene.audioElement.loop = true;
                      scene.audioElement.currentTime = 0;
                      scene.audioElement.play();
                    } else { // no separate mp3 for this scene - FIX: Don’t gate video audio on hasAudio
                      videoAudioSourceNode = audioContext.createMediaElementSource(bg);
                      videoAudioSourceNode.connect(destinationNode);
                    }

                    let sceneAnimFrame;
                    const videoAnimLoop = () => {
                      const now = performance.now();
                      if ((now - startTs) >= sceneDur) {
                        cancelAnimationFrame(sceneAnimFrame);
                        bg.pause(); bg.currentTime = 0;
                        if (scene.audioElement) { // Existing audio stop logic
                          scene.audioElement.pause();
                          scene.audioElement.currentTime = 0;
                          scene.audioElement.loop = false;
                        }
                        if (audioSourceNode) audioSourceNode.disconnect();
                        if (videoAudioSourceNode) videoAudioSourceNode.disconnect();
                        // restore loop default
                        bg.loop = true;
                        return sceneResolve();
                      }

                      if (bg.paused) {
                        bg.play().catch(() => {});
                      }

                      renderSceneFrameForGeneration(scene);
                      // draw active layers on top
                      scene.layers.forEach(l => {
                        recordingCtx.save();
                        recordingCtx.globalAlpha = l.opacity;
                        recordingCtx.filter = `brightness(${l.brightness}) saturate(${l.saturation})`;

                        const scaleX = recordingCanvas.width / movieCanvas.width;
                        const scaleY = recordingCanvas.height / movieCanvas.height;
                        const finalX = l.x * scaleX;
                        const finalY = l.y * scaleY;

                        recordingCtx.translate(finalX, finalY);
                        recordingCtx.rotate(l.rot * Math.PI / 180);
                        if (l.flipX) recordingCtx.scale(-1, 1);

                        if (l.type === 'image' || l.type === 'video') {
                          const assetWidth = l.type === 'image' ? l.asset.naturalWidth : l.asset.videoWidth;
                          const assetHeight = l.type === 'image' ? l.asset.naturalHeight : l.asset.videoHeight;
                          if (assetWidth > 0) {
                            const scaledSize = l.size * scaleX;
                            const dWidth = scaledSize;
                            const dHeight = scaledSize * (assetHeight / assetWidth);
                            recordingCtx.drawImage(l.asset, -dWidth / 2, -dHeight / 2, dWidth, dHeight);
                          }
                        } else if (l.type === 'text') {
                          const scaledFontSize = l.fontSize * scaleY;
                          recordingCtx.font = `${scaledFontSize}px ${l.font}`;
                          recordingCtx.fillStyle = l.color;
                          recordingCtx.textAlign = 'center';
                          recordingCtx.textBaseline = 'middle';
                          recordingCtx.fillText(l.text, 0, 0);
                        }
                        recordingCtx.restore();
                      });

                      sceneAnimFrame = requestAnimationFrame(videoAnimLoop);
                    };

                    bg.currentTime = 0;
                    bg.play().then(() => {
                      videoAnimLoop();
                    }).catch(() => {
                      // even if play fails (autoplay policies), keep drawing first frame
                      videoAnimLoop(); // Still call the loop to draw static frame if video doesn't play
                    });
                  });
                }
                // B) For image background scenes: render for scene.durationMs (not a fixed 3s)
                else { // Image background
                  await new Promise(sceneResolve => {
                    // const sceneDur = Math.max(scene.durationMs || 3000, 1000); // This line moved above
                    const startTs = performance.now();

                    // If an MP3 is attached, loop it during the whole sceneDur
                    let audioSourceNode = null;
                    if (scene.audioElement) {
                      audioSourceNode = audioContext.createMediaElementSource(scene.audioElement);
                      audioSourceNode.connect(destinationNode);
                      scene.audioElement.loop = true;
                      scene.audioElement.currentTime = 0;
                      scene.audioElement.play();
                    }

                    const drawFrame = () => {
                      const now = performance.now();
                      if ((now - startTs) >= sceneDur) {
                        if (scene.audioElement) { // Existing audio stop logic
                          scene.audioElement.pause();
                          scene.audioElement.currentTime = 0;
                          scene.audioElement.loop = false;
                        }
                        if (audioSourceNode) audioSourceNode.disconnect();
                        return sceneResolve();
                      }

                      renderSceneFrameForGeneration(scene);

                      // draw layers
                      scene.layers.forEach(l => {
                        recordingCtx.save();
                        recordingCtx.globalAlpha = l.opacity;
                        recordingCtx.filter = `brightness(${l.brightness}) saturate(${l.saturation})`;

                        const scaleX = recordingCanvas.width / movieCanvas.width;
                        const scaleY = recordingCanvas.height / movieCanvas.height;
                        const finalX = l.x * scaleX;
                        const finalY = l.y * scaleY;

                        recordingCtx.translate(finalX, finalY);
                        recordingCtx.rotate(l.rot * Math.PI / 180);
                        if (l.flipX) recordingCtx.scale(-1, 1);

                        if (l.type === 'image' || l.type === 'video') {
                          const assetWidth = l.type === 'image' ? l.asset.naturalWidth : l.asset.videoWidth;
                          const assetHeight = l.type === 'image' ? l.asset.naturalHeight : l.asset.videoHeight;
                          if (assetWidth > 0) {
                            const scaledSize = l.size * scaleX;
                            const dWidth = scaledSize;
                            const dHeight = scaledSize * (assetHeight / assetWidth);
                            recordingCtx.drawImage(l.asset, -dWidth / 2, -dHeight / 2, dWidth, dHeight);
                          }
                        } else if (l.type === 'text') {
                          const scaledFontSize = l.fontSize * scaleY;
                          recordingCtx.font = `${scaledFontSize}px ${l.font}`;
                          recordingCtx.fillStyle = l.color;
                          recordingCtx.textAlign = 'center';
                          recordingCtx.textBaseline = 'middle';
                          recordingCtx.fillText(l.text, 0, 0);
                        }
                        recordingCtx.restore();
                      });

                      requestAnimationFrame(drawFrame);
                    };

                    // initial draw & loop
                    drawFrame();
                  });
                }
            }

            finalRecorder.stop();
            return generationPromise;
        }


        // --- Interaction Logic ---
        function getMovieCanvasPoint(e) {
            const rect = movieCanvas.getBoundingClientRect();
            const clientX = e.clientX;
            const clientY = e.clientY;
            return { x: (clientX - rect.left) / rect.width * movieCanvas.width, y: (clientY - rect.top) / rect.height * movieCanvas.height };
        }

        function getMovieHandleAtPoint(point, layer) {
            const l = layer;
            let dWidth, dHeight;

            if (l.type === 'image' || l.type === 'video') {
                const assetWidth = l.type === 'image' ? l.asset.naturalWidth : l.asset.videoWidth;
                const assetHeight = l.type === 'image' ? l.asset.naturalHeight : l.asset.videoHeight;
                if (assetWidth === 0) return null;
                dWidth = l.size;
                dHeight = l.size * (assetHeight / assetWidth);
            } else if (l.type === 'text') {
                // These should have been calculated during the last drawControlsOverlay/drawMovieFrame
                if (!l.width || !l.height || l.width === 0) { // If not, do a quick measure on controlsCtx
                    controlsCtx.font = `${l.fontSize}px ${l.font}`;
                    const textMetrics = controlsCtx.measureText(l.text);
                    l.width = textMetrics.width;
                    l.height = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 4;
                }
                dWidth = l.width;
                dHeight = l.height;
            } else {
                return null;
            }

            const radius = 20;
            const angle = l.rot * Math.PI / 180;
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const ROTATION_HANDLE_OFFSET = 30;
            
            // Rotation handle math clean, correct version - FIX
            const rotHandleY = -dHeight / 2 - ROTATION_HANDLE_OFFSET;
            // rotate (0, rotHandleY) by l.rot around layer center and translate to world:
            const rotatedRotHandleX = l.x + (0 * cos - rotHandleY * sin); // Corrected to be relative to l.x
            const rotatedRotHandleY = l.y + (0 * sin + rotHandleY * cos); // Corrected to be relative to l.y

            if (Math.hypot(point.x - rotatedRotHandleX, point.y - rotatedRotHandleY) < radius) return 'rotate';

            const handles = {
                tl: { x: -dWidth / 2, y: -dHeight / 2 },
                tr: { x: dWidth / 2, y: -dHeight / 2 },
                bl: { x: -dWidth / 2, y: dHeight / 2 },
                br: { x: dWidth / 2, y: dHeight / 2 }
            };
            for (const name in handles) {
                const h = handles[name];
                const handleWorldX = l.x + h.x * cos - h.y * sin;
                const handleWorldY = l.y + h.x * sin + h.y * cos;
                if (Math.hypot(point.x - handleWorldX, point.y - handleWorldY) < radius) return name;
            }
            return null;
        }

        function isPointInMovieLayer(point, layer) {
            const l = layer;
            let dWidth, dHeight;

            if (l.type === 'image' || l.type === 'video') {
                const assetWidth = l.type === 'image' ? l.asset.naturalWidth : l.asset.videoWidth;
                const assetHeight = l.type === 'image' ? l.asset.naturalHeight : l.asset.videoHeight;
                if (assetWidth === 0) return false;
                dWidth = l.size;
                dHeight = l.size * (assetHeight / assetWidth);
            } else if (l.type === 'text') {
                if (!l.width || !l.height || l.width === 0) { // Quick measure if not available
                    controlsCtx.font = `${l.fontSize}px ${l.font}`;
                    const textMetrics = controlsCtx.measureText(l.text);
                    l.width = textMetrics.width;
                    l.height = textMetrics.actualBoundingBoxAscent + textMetrics.actualBoundingBoxDescent + 4;
                }
                dWidth = l.width;
                dHeight = l.height;
            } else {
                return false;
            }

            const dx = point.x - l.x;
            const dy = point.y - l.y;
            const angle = -l.rot * Math.PI / 180;
            const localX = dx * Math.cos(angle) - dy * Math.sin(angle);
            const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
            return (Math.abs(localX) < dWidth / 2 && Math.abs(localY) < dHeight / 2);
        }

        function handleMovieInteractionStart(e) {
            e.preventDefault();
            const point = getMovieCanvasPoint(e);
            const currentScene = getCurrentScene();
            if (!currentScene) return;

            // Find the top-most layer that was clicked
            let clickedLayer = null;
            for (let i = currentScene.layers.length - 1; i >= 0; i--) {
                const l = currentScene.layers[i];
                if (isPointInMovieLayer(point, l) || getMovieHandleAtPoint(point, l)) {
                    clickedLayer = l;
                    break;
                }
            }
            
            if (clickedLayer) {
                // If a new layer is clicked, make it active
                if (activeMovieLayerId !== clickedLayer.id) {
                    activeMovieLayerId = clickedLayer.id;
                    renderLayerPalette();
                    drawControlsOverlay();
                    updateEditPanelsUI();
                }

                const handle = getMovieHandleAtPoint(point, clickedLayer);
                if (handle) {
                    movieInteraction = { active: true, type: handle === 'rotate' ? 'rotate' : 'resize', layerId: clickedLayer.id, handle, startX: point.x, startY: point.y, initialState: JSON.parse(JSON.stringify(clickedLayer)) };
                } else { // Drag
                    movieInteraction = {
                        active: true, type: 'drag', layerId: clickedLayer.id,
                        offsetX: point.x - clickedLayer.x,
                        offsetY: point.y - clickedLayer.y,
                        targetX: clickedLayer.x,
                        targetY: clickedLayer.y,
                        primed: isCountdownActive
                    };
                }
                startAnimationLoop(); // Ensure animation loop is running for smooth interaction
                return;
            }

            // If no layer was clicked, deactivate any active layer
            if (activeMovieLayerId) {
                 activeMovieLayerId = null;
                 renderLayerPalette();
                 drawControlsOverlay();
                 updateEditPanelsUI();
            }
        }

        function handleMovieInteractionMove(e) {
            if (!movieInteraction.active) { updateCursor(e); return; }
            e.preventDefault();
            const point = getMovieCanvasPoint(e);
            const l = getActiveLayer(); // Now always refers to the active layer from state
            if (!l) return;

            if (movieInteraction.type === 'drag') {
                movieInteraction.targetX = point.x - movieInteraction.offsetX;
                movieInteraction.targetY = point.y - movieInteraction.offsetY;
            } else if (movieInteraction.type === 'resize') {
                const iState = movieInteraction.initialState;
                const initialDist = Math.hypot(movieInteraction.startX - iState.x, movieInteraction.startY - iState.y);
                const currentDist = Math.hypot(point.x - iState.x, point.y - iState.y);
                
                if (initialDist > 1) {
                    const scaleFactor = currentDist / initialDist;
                    if (l.type === 'text') {
                        l.fontSize = Math.max(10, iState.fontSize * scaleFactor);
                    } else { // image or video
                        l.size = Math.max(20, iState.size * scaleFactor);
                    }
                }
            } else if (movieInteraction.type === 'rotate') {
                const iState = movieInteraction.initialState;
                const initialAngle = Math.atan2(movieInteraction.startY - iState.y, movieInteraction.startX - iState.x) * 180 / Math.PI;
                const currentAngle = Math.atan2(point.y - iState.y, point.x - iState.x) * 180 / Math.PI;
                l.rot = iState.rot + (currentAngle - initialAngle);
            }
        }
        function handleMovieInteractionEnd(e) {
            movieInteraction.active = false;
        }

        function updateCursor(e) {
            const point = getMovieCanvasPoint(e);
            const currentScene = getCurrentScene(); if (!currentScene) return;
            let newCursor = 'default';
            
            // Check active layer first for handles
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                const handle = getMovieHandleAtPoint(point, activeLayer);
                if (handle) {
                    newCursor = handle === 'rotate' ? 'grab' : (handle === 'tl' || handle === 'br' ? 'nwse-resize' : 'nesw-resize');
                } else if (isPointInMovieLayer(point, activeLayer)) {
                    newCursor = 'move';
                }
            }

            // If no active layer or no handle/body was hit on active layer, check other layers for pointer
            if (newCursor === 'default') {
                 for (let i = currentScene.layers.length - 1; i >= 0; i--) {
                     const l = currentScene.layers[i];
                     if (isPointInMovieLayer(point, l)) {
                         newCursor = 'pointer'; // Indicate it's clickable to activate/drag
                         break;
                     }
                 }
            }
            movieCanvas.style.cursor = newCursor;
        }

        function continuousResizeLoop() {
            if (!resizeState.isResizing) return;
            const activeLayer = getActiveLayer();
            if (activeLayer) {
                if (activeLayer.type === 'text') {
                    activeLayer.fontSize = Math.max(10, activeLayer.fontSize + RESIZE_SPEED * resizeState.direction);
                } else { // image or video
                    activeLayer.size = Math.max(20, activeLayer.size + RESIZE_SPEED * resizeState.direction);
                }
            }
            resizeState.animationFrameId = requestAnimationFrame(continuousResizeLoop);
        }

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            // Allow typing in text content input without triggering other shortcuts
            if (document.activeElement === textContentInput) {
                if (key === 'escape') {
                    textContentInput.blur(); // Unfocus the input
                    e.preventDefault(); // Prevent other potential escape actions
                }
                return; 
            }
            if (document.activeElement.tagName === 'INPUT') return; // For any other input element
            
            const activeLayer = getActiveLayer();
            
            if (key === 'r') {
                e.preventDefault();
                if (isRecording) {
                    stopMovieRecording();
                } else if (!recordLayerBtn.disabled) {
                    startMovieRecording();
                }
                return;
            }

            if (!activeLayer) return;

            if (key === 's') {
                e.preventDefault();
                activeLayer.flipX = !activeLayer.flipX;
            } else if (key === 'd' || key === 'f') {
                e.preventDefault();
                if (resizeState.isResizing) return; // Prevent multiple loops
                resizeState.isResizing = true;
                resizeState.direction = (key === 'd') ? 1 : -1;
                continuousResizeLoop();
            } else if (!isRecording) {
                switch (key) {
                    case 'delete': case 'backspace':
                        e.preventDefault(); deleteMovieLayer(activeLayer.id); toast('Layer deleted', 2000); break;
                }
            }
        }

        function handleKeyUp(e) {
            const key = e.key.toLowerCase();
            if (key === 'd' || key === 'f') {
                e.preventDefault();
                resizeState.isResizing = false;
                cancelAnimationFrame(resizeState.animationFrameId);
            }
        }
        
        function clearProject() {
            scenes.forEach(scene => {
                if (scene.audioElement) {
                    URL.revokeObjectURL(scene.audioElement.src);
                }
                // Revoke URLs for committed layers if they are object URLs
                scene.committedLayerSrcs.forEach(src => {
                    if (src.startsWith('blob:')) URL.revokeObjectURL(src);
                });
            });
            scenes = [];
            activeSceneId = null;
            activeMovieLayerId = null;
            lastRecordingDurationMs = 0; // Reset this too
            
            movieCtx.clearRect(0,0,movieCanvas.width, movieCanvas.height);
            controlsCtx.clearRect(0,0,controlsOverlayCanvas.width, controlsOverlayCanvas.height);
            canvasPlaceholder.classList.remove('hidden');
            sceneTray.innerHTML = '';
            
            updateControlsState();
            updateEditPanelsUI(); // Update all panel UIs
            updateAudioUI();
            toast("Project cleared.", 2000);
        }

        let confirmCallback = null;
        function openConfirmationModal(text, onConfirm) {
            confirmationText.textContent = text;
            confirmCallback = onConfirm;
            confirmationOverlay.classList.add('visible');
        }
        function closeConfirmationModal() {
            confirmationOverlay.classList.remove('visible');
            confirmCallback = null;
        }
        
        const setupEventListeners = () => {
            const setValNull = e => e.target.value = null;
            initialBackgroundInput.addEventListener('change', e => { handleBackgroundUpload(e.target.files[0], 'initial'); setValNull(e); });
            
            addSceneBtn.addEventListener('click', () => {
                if (scenes.length === 0) {
                    initialBackgroundInput.click();
                } else {
                    newSceneBackgroundInput.click();
                }
            });

            newSceneBackgroundInput.addEventListener('change', e => { handleBackgroundUpload(e.target.files[0], 'add'); setValNull(e); });
            
            document.getElementById('mg-asset-library-close').addEventListener('click', closeAssetLibrary);
            assetLibraryOverlay.addEventListener('click', (e) => { if (e.target === assetLibraryOverlay) closeAssetLibrary(); });
            assetPickerFileInput.addEventListener('change', async (e) => {
                const file = e.target.files?.[0];
                if (!file) return;

                const isImage = file.type.startsWith('image/');
                const isVideo = file.type.startsWith('video/');

                if (!isImage && !isVideo) {
                    toast('Unsupported file. Use PNG, MP4, or MOV.', 3000);
                    setValNull(e);
                    return;
                }

                // Check for existing image/video layer
                const currentScene = getCurrentScene();
                if (currentScene?.layers.some(l => l.type === 'image' || l.type === 'video')) {
                    toast('An image or video asset already exists. Delete it before adding a new one.', 4000);
                    setValNull(e);
                    return;
                }

                async function canPlayVideoFile(f) {
                    return await new Promise((resolve) => {
                        const vid = document.createElement('video');
                        vid.muted = true;
                        vid.preload = 'metadata';
                        const url = URL.createObjectURL(f);
                        const cleanup = () => URL.revokeObjectURL(url);
                        vid.src = url;
                        vid.addEventListener('loadeddata', () => { cleanup(); resolve(true); }, { once: true });
                        vid.addEventListener('error',      () => { cleanup(); resolve(false); }, { once: true });
                    });
                }

                if (isVideo) {
                    const playable = await canPlayVideoFile(file);
                    if (!playable) {
                        toast('This video codec isn’t supported by your browser. Convert to MP4 (H.264/AAC) or WebM (VP9/Opus).', 6000);
                        setValNull(e);
                        return;
                    }
                }

                const fileURL = URL.createObjectURL(file);
                addMovieLayer(fileURL, { type: isImage ? 'image' : 'video' });
                closeAssetLibrary();
                setValNull(e);
            });

            // Re-wired textBtn to handle both adding and editing
            textBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                const currentScene = getCurrentScene();
                const hasTextLayer = currentScene?.layers.some(l => l.type === 'text');

                if (!currentScene) {
                    toast('Please add a background to the scene first.', 2000);
                    return;
                }
                if (isRecording) {
                    toast('Cannot add/edit text while recording.', 2000);
                    return;
                }

                if (hasTextLayer) {
                    // If text layer exists, toggle dropdown for editing
                    textDropdown.classList.toggle('visible');
                    // Ensure active layer is set to text for controls to work
                    const textLayer = currentScene.layers.find(l => l.type === 'text');
                    if (textLayer && activeMovieLayerId !== textLayer.id) {
                        activeMovieLayerId = textLayer.id;
                        renderLayerPalette();
                        drawControlsOverlay();
                        updateEditPanelsUI();
                    }
                } else {
                    // If no text layer, add one directly
                    addTextLayer();
                }
                
                // Close other dropdowns
                shortcutsDropdown.classList.remove('visible');
                visualsDropdown.classList.remove('visible');
                audioDropdown.classList.remove('visible');
            });


            recordLayerBtn.addEventListener('click', startMovieRecording);
            stopLayerBtn.addEventListener('click', stopMovieRecording);
            previewSceneBtn.addEventListener('click', previewCurrentScene);
            commitLayerBtn.addEventListener('click', () => {
                const currentScene = getCurrentScene();
                if (!currentScene || !layerRecordingUrl) return; // Must have a recording to commit

                // In the Commit handler for commitLayerBtn:
                ensureSceneDurationMs(currentScene, Math.max(500, lastRecordingDurationMs));


                // Iterate through ALL active layers to capture their individual representations for committedLayerSrcs
                currentScene.layers.forEach(recordedLayer => {
                    let layerRepresentationSrc = '';
                    if (recordedLayer.type === 'image' || recordedLayer.type === 'video') {
                        layerRepresentationSrc = recordedLayer.src;
                    } else if (recordedLayer.type === 'text') {
                        // Render the text layer statically to a canvas to get an image data URL
                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = movieCanvas.width; // Use current canvas dimensions for snapshot
                        tempCanvas.height = movieCanvas.height;
                        const tempCtx = tempCanvas.getContext('2d');

                        // Draw just the text layer as it appeared
                        tempCtx.font = `${recordedLayer.fontSize}px ${recordedLayer.font}`;
                        tempCtx.fillStyle = recordedLayer.color;
                        tempCtx.textAlign = 'center';
                        tempCtx.textBaseline = 'middle';
                        
                        tempCtx.save();
                        tempCtx.globalAlpha = recordedLayer.opacity;
                        tempCtx.filter = `brightness(${recordedLayer.brightness}) saturate(${recordedLayer.saturation})`;
                        tempCtx.translate(recordedLayer.x, recordedLayer.y);
                        tempCtx.rotate(recordedLayer.rot * Math.PI / 180);
                        if (recordedLayer.flipX) { tempCtx.scale(-1, 1); }
                        tempCtx.fillText(recordedLayer.text, 0, 0);
                        tempCtx.restore();

                        layerRepresentationSrc = tempCanvas.toDataURL('image/png');
                    }
                    if (layerRepresentationSrc) {
                        currentScene.committedLayerSrcs.push(layerRepresentationSrc);
                    }
                });

                // The recorded video (containing all layers) becomes the new background
                fetch(layerRecordingUrl)
                    .then(res => res.blob())
                    .then(blob => {
                        handleBackgroundUpload(blob, '', true); // This will also clear active layers
                        lastRecordingDurationMs = 0; // Reset lastRecordingDurationMs on commit

                        // Post-commit safeguard: if the new video metadata is still warming up,
                        // re-assert the longest duration once its metadata is ready.
                        const scene = getCurrentScene();
                        if (scene && scene.backgroundType === 'video') {
                          const bg = scene.backgroundElement;
                          const finalizeDur = () => {
                            ensureSceneDurationMs(scene, getMediaDurationMs(bg, 'video'));
                          };
                          if (bg.readyState >= 1) finalizeDur();
                          else bg.addEventListener('loadedmetadata', finalizeDur, { once: true });
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching recorded blob for commit:', error);
                        toast('Failed to commit layer.', 4000);
                        resetToReadyState(); // Try to reset gracefully
                    });
            });
            generateProjectBtn.addEventListener('click', generateFinalMovie);
            movieDownloadBtn.addEventListener('click', () => {
                if (finalProjectUrl) {
                    const link = document.createElement('a'); link.href = finalProjectUrl; 
                    const fileExtension = movieDownloadBtn.dataset.filetype === 'video/mp4' ? '.mp4' : '.webm';
                    link.download = `movie-maker-masterpiece${fileExtension}`;
                    document.body.appendChild(link); link.click(); document.body.removeChild(link);
                } else toast('No final project available.', 2000);
            });

            previewBtn.addEventListener('click', () => {
                if(finalProjectUrl) {
                    previewVideo.src = finalProjectUrl;
                    previewVideo.currentTime = 0;
                    previewPopup.classList.add('visible');
                }
            });
            document.getElementById('mg-preview-close-btn').addEventListener('click', () => {
                previewVideo.pause();
                previewPopup.classList.remove('visible');
            });

            deleteSceneBtn.addEventListener('click', () => {
                const text = "This will permanently delete the current scene. Are you sure?";
                openConfirmationModal(text, () => {
                    deleteScene(activeSceneId);
                    closeConfirmationModal();
                });
            });
            confirmYesBtn.addEventListener('click', () => { if(confirmCallback) confirmCallback(); });
            confirmNoBtn.addEventListener('click', closeConfirmationModal);
            confirmationOverlay.addEventListener('click', closeConfirmationModal);
            document.getElementById('mg-confirmation-dialog').addEventListener('click', e => e.stopPropagation());

            movieCanvas.addEventListener('mousedown', handleMovieInteractionStart);
            window.addEventListener('mousemove', handleMovieInteractionMove);
            window.addEventListener('mouseup', handleMovieInteractionEnd);
            movieCanvas.addEventListener('mouseleave', () => { if (!movieInteraction.active) { movieCanvas.style.cursor = 'default'; }});
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);

            videoVolumeBtn.addEventListener('click', (e) => { e.stopPropagation(); videoVolumeControls.classList.toggle('open'); });
            videoVolumeSlider.addEventListener('input', (e) => {
                const currentScene = getCurrentScene();
                if (currentScene && currentScene.backgroundType === 'video') { currentScene.backgroundElement.volume = e.target.value; }
            });
            videoVolumeControls.addEventListener('click', e => e.stopPropagation());
            
            canvasPlaceholder.addEventListener('click', () => initialBackgroundInput.click());
            canvasPanel.addEventListener('dragover', (e) => { e.preventDefault(); if (scenes.length === 0) canvasPanel.classList.add('drag-over'); });
            canvasPanel.addEventListener('dragleave', (e) => { e.preventDefault(); canvasPanel.classList.remove('drag-over'); });
            canvasPanel.addEventListener('drop', (e) => {
                e.preventDefault();
                canvasPanel.classList.remove('drag-over');
                if (scenes.length === 0) {
                    const file = e.dataTransfer.files[0];
                    if (file) handleBackgroundUpload(file, 'initial');
                }
            });

            shortcutsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                shortcutsDropdown.classList.toggle('visible');
                visualsDropdown.classList.remove('visible');
                textDropdown.classList.remove('visible'); // Close text dropdown
                audioDropdown.classList.remove('visible');
            });

            visualsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                visualsDropdown.classList.toggle('visible');
                shortcutsDropdown.classList.remove('visible');
                textDropdown.classList.remove('visible'); // Close text dropdown
                audioDropdown.classList.remove('visible');
                if (visualsDropdown.classList.contains('visible')) {
                    updateEditPanelsUI(); // Update asset visuals and background visuals
                }
            });

            audioBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                audioDropdown.classList.toggle('visible');
                shortcutsDropdown.classList.remove('visible');
                visualsDropdown.classList.remove('visible');
                textDropdown.classList.remove('visible'); // Close text dropdown
                if (audioDropdown.classList.contains('visible')) {
                    updateAudioUI();
                }
            });

            visualsDropdown.addEventListener('click', e => e.stopPropagation());
            textDropdown.addEventListener('click', e => e.stopPropagation()); // Prevent closing when interacting with text controls
            audioDropdown.addEventListener('click', e => e.stopPropagation());

            sceneAudioInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                const currentScene = getCurrentScene();
                if (!file || !currentScene) return;

                if (currentScene.audioElement) {
                    URL.revokeObjectURL(currentScene.audioElement.src);
                }
                const audioURL = URL.createObjectURL(file);
                currentScene.audioElement = new Audio(audioURL);
                currentScene.audioName = file.name;

                // When adding scene audio, bump duration if the audio is longer
                currentScene.audioElement.addEventListener('loadedmetadata', () => {
                  const aDur = Math.floor((currentScene.audioElement.duration || 0) * 1000);
                  currentScene.audioDurationMs = aDur; // store, but don't extend scene duration
                });

                toast('Audio added! It will play during recording.', 4000);
                updateAudioUI();
                setValNull(e);
            });

            removeAudioBtn.addEventListener('click', () => {
                const currentScene = getCurrentScene();
                if (currentScene && currentScene.audioElement) {
                    URL.revokeObjectURL(currentScene.audioElement.src);
                    currentScene.audioElement = null;
                    currentScene.audioName = null;
                    currentScene.audioDurationMs = 0; // Reset audio duration
                    toast('Audio removed from scene.', 2000);
                    updateAudioUI();
                }
            });

            // Universal Asset Visuals (opacity, brightness, saturation)
            assetOpacitySlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && (activeLayer.type === 'image' || activeLayer.type === 'video')) activeLayer.opacity = parseFloat(e.target.value);
            });
            assetBrightnessSlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && (activeLayer.type === 'image' || activeLayer.type === 'video')) activeLayer.brightness = parseFloat(e.target.value);
            });
            assetSaturationSlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && (activeLayer.type === 'image' || activeLayer.type === 'video')) activeLayer.saturation = parseFloat(e.target.value);
            });

            // Text Visuals Controls
            textContentInput.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.text = e.target.value;
                    drawMovieFrame(); // Redraw immediately to show text change
                    drawControlsOverlay(); // Redraw controls for updated text bounds
                    renderLayerPalette(); // Update text thumbnail in palette
                }
            });
            textFontSelect.addEventListener('change', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.font = e.target.value;
                    drawMovieFrame();
                    drawControlsOverlay();
                    renderLayerPalette(); // Update text thumbnail in palette
                }
            });
            textSizeSlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.fontSize = parseFloat(e.target.value);
                    drawMovieFrame();
                    drawControlsOverlay();
                }
            });
            textColorInput.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.color = e.target.value;
                    drawMovieFrame();
                }
            });
            textOpacitySlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.opacity = parseFloat(e.target.value);
                }
            });
            textBrightnessSlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.brightness = parseFloat(e.target.value);
                }
            });
            textSaturationSlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer && activeLayer.type === 'text') {
                    activeLayer.saturation = parseFloat(e.target.value);
                }
            });

            bgBrightnessSlider.addEventListener('input', e => {
                const scene = getCurrentScene();
                if (scene) scene.bgBrightness = parseFloat(e.target.value);
            });
            bgSaturationSlider.addEventListener('input', e => {
                const scene = getCurrentScene();
                if (scene) scene.bgSaturation = parseFloat(e.target.value);
            });

            const allSliders = document.querySelectorAll('input[type="range"]');
            allSliders.forEach(slider => {
                slider.addEventListener('mousedown', () => isDraggingSlider = true);
            });

            const visualsSliders = document.querySelectorAll('#visuals-dropdown input[type="range"]');
            
            const handleSliderScrubStart = (e) => {
                const sliderContainer = e.target.closest('.slider-container');
                if (sliderContainer) {
                    visualsDropdown.classList.add('is-scrubbing');
                    sliderContainer.classList.add('is-active-slider');
                }
            }

            const handleSliderScrubEnd = () => {
                visualsDropdown.classList.remove('is-scrubbing');
                const activeSlider = document.querySelector('.is-active-slider');
                if (activeSlider) {
                    activeSlider.classList.remove('is-active-slider');
                }
            }
            
            visualsSliders.forEach(slider => {
                slider.addEventListener('mousedown', handleSliderScrubStart);
            });

            const endDrag = () => {
                setTimeout(() => { isDraggingSlider = false; }, 50);
                handleSliderScrubEnd();
            };

            window.addEventListener('mouseup', endDrag);

            // Universal click listener to close dropdowns
            window.addEventListener('click', (e) => {
                if (isDraggingSlider) return;

                if (videoVolumeControls.classList.contains('open')) videoVolumeControls.classList.remove('open');
                if (shortcutsDropdown.classList.contains('visible')) shortcutsDropdown.classList.remove('visible');
                if (visualsDropdown.classList.contains('visible')) visualsDropdown.classList.remove('visible');
                if (textDropdown.classList.contains('visible')) textDropdown.classList.remove('visible');
                if (audioDropdown.classList.contains('visible')) audioDropdown.classList.remove('visible');
            });

            const canvasResizeObserver = new ResizeObserver(resizeCanvas);
            canvasResizeObserver.observe(canvasPanel);
        };

        updateControlsState();
        updateEditPanelsUI(); // Call the unified update function
        updateAudioUI();
        setupEventListeners();
        startAnimationLoop();
    })();
</script>
</body>
</html>
