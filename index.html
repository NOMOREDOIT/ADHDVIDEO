<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Movie Meme Maker Studio</title>
    <link rel="icon" type="image/png" href="favicon.ico">
    <link href="https://fonts.googleapis.com/css2?family=VT323&display=swap" rel="stylesheet">
<style>
    :root {
        --bg: #f2efe8; --ink: #2b2b2b; --mid: #c2c2c2; --light: #faf9f5;
        --light-rgb: 250, 249, 245;
        --shadow: #7a7a7a; --danger-color: #cc4444; --action-color: #4477cc;
        --success-color: #55cc55;
    }
    html {
      box-sizing: border-box;
    }
    *, *:before, *:after {
      box-sizing: inherit;
    }
    body {
        font-family: 'VT323', monospace; background: var(--bg) url('./assets/wallpaper.png') repeat fixed;
        color: var(--ink); display: flex; flex-direction: column; align-items: center;
        padding: 10px; margin: 0; height: 100vh; overflow: hidden;
    }
    .window {
        background: var(--light); border: 2px solid var(--ink); box-shadow: 4px 4px 0px var(--ink);
        width: 100%; max-width: 1600px; margin: 0 auto; height: calc(100vh - 20px);
        display: flex; flex-direction: column;
        overflow: hidden;
    }
    .titlebar {
        height: 28px; background: var(--mid); display: flex; align-items: center;
        justify-content: space-between; padding: 0 8px; border-bottom: 2px solid var(--ink);
        font-size: 20px; flex-shrink: 0; cursor: default;
        position: relative;
    }
    .titlebar-controls {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    .controls-fake { display: flex; gap: 4px; }
    .btn-square { width: 16px; height: 16px; background: var(--light); border: 2px solid var(--ink); }
    .controls-fake .btn-square:first-child { background-color: var(--success-color); }
    .controls-fake .btn-square:last-child { background-color: var(--danger-color); }

    #shortcuts-btn, #visuals-btn {
        font-family: inherit;
        font-size: 16px;
        background: var(--light);
        border: 2px solid var(--ink);
        padding: 0 8px;
        cursor: pointer;
    }
    #shortcuts-dropdown {
        display: none;
        position: absolute;
        top: 28px;
        right: 8px;
        background: var(--light);
        border: 2px solid var(--ink);
        box-shadow: 4px 4px 0px var(--ink);
        padding: .5rem 1rem;
        z-index: 100;
        width: 250px;
    }
    #shortcuts-dropdown.visible {
        display: block;
    }
    #shortcuts-dropdown h5 {
        margin: 0 0 .5rem 0;
        font-size: 1.2rem;
        text-align: center;
    }
    #shortcuts-dropdown ul {
        margin: 0;
        padding: 0;
        list-style: none;
        font-size: 1rem;
    }
     #shortcuts-dropdown li {
        display: flex;
        justify-content: space-between;
        padding: 2px 0;
     }
     #shortcuts-dropdown li kbd {
        font-family: inherit;
        border: 2px solid var(--ink);
        padding: 0 4px;
        background: var(--bg);
     }

    /* Style for the visuals dropdown panel */
    #visuals-dropdown {
        display: none;
        position: absolute;
        top: 28px;
        right: 102px; /* Adjust as needed based on your other buttons */
        background: rgba(var(--light-rgb), 0.3);
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
        border: 2px solid var(--ink);
        box-shadow: 4px 4px 0px var(--ink);
        padding: .5rem 1rem;
        z-index: 100;
        width: 250px;
        transition: background .2s, backdrop-filter .2s, box-shadow .2s, border-color .2s;
    }

    #visuals-dropdown.visible { display: block; }
    #visuals-dropdown h5, #visuals-dropdown h6, #visuals-dropdown .slider-container {
        transition: opacity .2s;
    }
    #visuals-dropdown h5 { margin: 0 0 .5rem 0; font-size: 1.2rem; text-align: center; }
    #visuals-dropdown h6 { font-size: 1.1rem; font-weight: bold; text-align: left; margin-top: .5rem; margin-bottom: .5rem; border-bottom: 2px solid var(--mid); padding-bottom: 2px; }
    #visuals-dropdown label { display: block; margin-top: .5rem; font-size: .9rem; }

    /* === SCRUBBING BEHAVIOR === */
    #visuals-dropdown.is-scrubbing {
        background: transparent;
        backdrop-filter: none;
        -webkit-backdrop-filter: none;
        box-shadow: none;
        border-color: transparent;
    }
    #visuals-dropdown.is-scrubbing > h5,
    #visuals-dropdown.is-scrubbing > div > h6,
    #visuals-dropdown.is-scrubbing .slider-container {
        opacity: 0;
        pointer-events: none;
    }
    #visuals-dropdown.is-scrubbing .slider-container.is-active-slider {
        opacity: 1;
        pointer-events: auto;
    }
    /* === END SCRUBBING === */

    #visuals-dropdown input[type="range"] {
        width: 100%;
        -webkit-appearance: none;
        appearance: none;
        height: 2px;
        background: var(--ink);
        outline: none;
    }
    #visuals-dropdown input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none; appearance: none;
        width: 16px; height: 16px;
        background: var(--ink);
        border-radius: 50%; cursor: pointer;
    }
    #visuals-dropdown input[type="range"]::-moz-range-thumb {
        width: 16px; height: 16px;
        background: var(--ink);
        border-radius: 50%; cursor: pointer; border: none;
    }

    #asset-visuals-controls.disabled { opacity: 0.5; pointer-events: none; }


    .mg-btn {
        font-family: inherit; font-size: 18px; background: var(--light); border: 2px solid var(--ink);
        padding: 8px 16px; margin: 4px; cursor: pointer; text-decoration: none;
        color: var(--ink); transition: .2s all; box-shadow: 2px 2px 0px var(--shadow); width: 100%;
        white-space: nowrap;
    }
    .mg-btn:hover { transform: translate(2px, 2px); box-shadow: 0px 0px 0px var(--shadow); }
    .mg-btn:disabled, .mg-btn.disabled {
        opacity: 0.5; pointer-events: none; box-shadow: none; transform: none;
    }
    .mg-btn.active { background-color: var(--danger-color); color: var(--light); box-shadow: none; transform: translate(2px, 2px); }
    .mg-btn.success { background-color: var(--success-color); }
    .mg-btn.record { background-color: var(--danger-color); color: var(--light); }
    .mg-btn.generate { background-color: var(--ink); color: var(--light); }


    .hidden { display: none !important; }
    #studio-container {
        display: grid;
        grid-template-columns: 320px 1fr;
        grid-template-rows: minmax(0, 1fr);
        gap: 1.5rem;
        padding: 1.5rem;
        flex-grow: 1;
        min-height: 0;
    }
    #controls-panel {
        display: flex; flex-direction: column; gap: 1rem; overflow-y: auto; min-height: 0;
    }
    #canvas-panel {
        display: flex; align-items: center; justify-content: center;
        border: 2px solid var(--ink); background-color: var(--mid);
        position: relative;
        min-height: 0;
    }
    #controls-panel fieldset {
        background: var(--light); border: 2px solid var(--ink);
        padding: .8rem; margin: 0; text-align: left;
    }
    #controls-panel legend { font-size: 1.2rem; font-weight: normal; padding: 0 .25rem; }
    .action-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem; }
    .scene-controls-container { display: flex; flex-direction: column; gap: 0.5rem; }
    /* === UI REFINEMENT: Fix button margins inside fieldset === */
    .scene-controls-container > .mg-btn {
        margin-left: 0;
        margin-right: 0;
    }
    
    /* === FIX: Prevent scene control buttons from expanding their container === */
    #scene-actions-container .mg-btn, #mg-commit-layer-btn {
        white-space: normal;
        text-align: center;
    }


    #recording-status {
        display: flex; align-items: center; justify-content: center; gap: 8px;
        font-size: 1.2rem; color: var(--danger-color);
    }
    #recording-indicator {
        width: 12px; height: 12px; background-color: var(--danger-color);
        border: 1px solid var(--ink); border-radius: 50%; animation: blink 1s infinite;
    }
    @keyframes blink { 50% { opacity: 0.3; } }
    .placeholder-text { color: var(--shadow); font-size: 0.9rem; text-align: center; padding: 1rem; width: 100%; }

    #mg-asset-palette {
        display: flex; gap: 0.5rem; flex-wrap: wrap;
        min-height: 70px; align-content: flex-start;
    }

    .palette-slot, .layer-thumb {
        width: 60px; height: 60px; border: 2px solid var(--ink); background: var(--light);
        cursor: pointer; position: relative; box-shadow: 2px 2px 0px var(--shadow);
    }
    .layer-thumb.locked {
        opacity: 0.6;
        cursor: default;
        box-shadow: none;
    }
    .layer-thumb.locked .layer-controls {
        display: none;
    }
    .layer-thumb.locked:hover .layer-controls {
        display: flex;
    }

    .layer-thumb { cursor: grab; }
    .palette-slot.empty {
        display: flex; align-items: center; justify-content: center;
        font-size: 3rem; line-height: 1; color: var(--mid);
        transition: all .2s;
    }
    .palette-slot.empty:hover { background-color: #e0e0e0; color: var(--ink); }
    .layer-thumb img {
        width: 100%; height: 100%; object-fit: cover; pointer-events: none;
    }
    .layer-thumb.active { border: 2px solid var(--action-color); transform: scale(1.05); box-shadow: none; }
    .layer-controls { position: absolute; top: -5px; right: -5px; display: flex; gap: 2px; }
    .layer-btn {
        background-color: var(--danger-color); border: 1px solid var(--ink);
        color: #fff; font-size: .8rem; font-weight: bold; line-height: 1; padding: 1px 4px;
        cursor: pointer; width: 18px; height: 18px; text-align: center;
    }

    #scene-tray {
        display: flex; gap: 0.5rem; flex-wrap: wrap; min-height: 65px;
        align-content: flex-start; padding-bottom: 0.5rem;
        border-bottom: 2px solid var(--mid); margin-bottom: 0.5rem;
    }
    .scene-thumb {
        width: 80px; height: 55px; border: 2px solid var(--ink); background-color: var(--mid);
        cursor: pointer; position: relative; box-shadow: 2px 2px 0px var(--shadow);
        background-size: cover; background-position: center; display: flex;
        color: var(--light); text-shadow: 1px 1px 0 var(--ink); align-items: center;
        justify-content: center; font-size: 1.5rem; transition: all .2s;
    }
    .scene-thumb.active { border-color: var(--action-color); transform: scale(1.05); box-shadow: 0px 0px 0px var(--shadow); }
    .scene-delete-btn {
        position: absolute; top: -5px; right: -5px; background-color: var(--danger-color);
        border: 1px solid var(--ink); color: #fff; font-size: .8rem; font-weight: bold;
        line-height: 1; padding: 1px 4px; cursor: pointer; width: 18px; height: 18px;
        text-align: center; opacity: 0; transition: opacity .2s;
    }
    .scene-thumb:hover .scene-delete-btn { opacity: 1; }
    .scene-thumb.active:hover .scene-delete-btn { display: none; }

    #mg-movie-canvas, #mg-controls-overlay-canvas {
        position: absolute;
    }
    #mg-controls-overlay-canvas {
        pointer-events: none;
    }
    #mg-movie-canvas {
        pointer-events: auto;
    }

    #video-volume-controls {
        position: absolute;
        bottom: 10px;
        right: 10px;
        display: flex;
        align-items: center;
        justify-content: flex-end;
        z-index: 10;
        height: 34px;
    }
    #video-volume-btn {
        font-size: 1.5rem;
        cursor: pointer;
        padding: 4px;
        user-select: none;
        background: none;
        border: none;
    }
    #volume-slider-wrapper {
        display: flex;
        align-items: center;
        width: 0;
        opacity: 0;
        overflow: hidden;
        transition: width 0.35s ease-in-out, opacity 0.35s ease-in-out;
    }
    #video-volume-controls.open #volume-slider-wrapper {
        width: 100px;
        opacity: 1;
        margin-right: 8px;
    }
    #video-volume-slider {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        height: 2px;
        background: var(--ink);
        outline: none;
    }
    #video-volume-slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 16px;
        height: 16px;
        background: var(--ink);
        border-radius: 50%;
        cursor: pointer;
    }
    #video-volume-slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        background: var(--ink);
        border-radius: 50%;
        cursor: pointer;
        border: none;
    }

    .mg-overlay-base {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1000;
        display: flex; align-items: center; justify-content: center; opacity: 0; visibility: hidden;
        pointer-events: none; transition: opacity 0.3s, visibility 0s 0.3s; background: rgba(10, 10, 10, 0.25);
    }
    .mg-overlay-base.visible { opacity: 1; visibility: visible; pointer-events: auto; transition: opacity 0.3s, visibility 0s 0s; }

    .overlay-close-btn {
        position: absolute; top: 8px; right: 10px; background: none; border: none;
        line-height: 1; cursor: pointer; padding: 5px; font-family: 'VT323', monospace;
        color: var(--ink);
        font-size: 2rem; z-index: 10;
        transition: opacity 0.2s;
    }
    .overlay-close-btn:hover {
        opacity: 0.6;
    }

    #mg-asset-picker-grid-wrapper {
        background: var(--light); border: 2px solid var(--ink); box-shadow: 4px 4px 0px var(--ink);
        padding: 1.5rem; max-width: 800px; width: 90vw; max-height: 85vh;
        display: flex; flex-direction: column; position: relative;
    }
    #mg-asset-picker-grid-wrapper h4 { font-size: 1.5rem; text-align: center; font-weight: normal; margin: 0 0 1rem; }
    #mg-asset-picker-grid {
        display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
        gap: 0.5rem; overflow-y: auto; padding: 0.5rem; flex-grow: 1;
    }
    .mg-template { width: auto; height: 80px; }
    .mg-template img { width: 100%; height: 100%; object-fit: contain; cursor: pointer; }
    #mg-asset-picker-actions { margin-top: 1rem; text-align: center; display: flex; gap: 0.5rem; justify-content: center; }
    #mg-toast {
        visibility: hidden; position: fixed; bottom: 20px; left: 50%;
        transform: translateX(-50%); background: var(--light); border: 2px solid var(--ink);
        padding: .5rem 1rem; color: var(--ink); font-size: 1rem;
        z-index: 2000; box-shadow: 4px 4px 0 var(--ink);
    }

    #mg-countdown-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        background: transparent;
        display: flex; align-items: center;
        justify-content: center; z-index: 3000; color: var(--light);
        text-shadow: 2px 2px 0 var(--ink), -2px -2px 0 var(--ink), 2px -2px 0 var(--ink), -2px 2px 0 var(--ink);
        font-size: 15vw;
        pointer-events: auto;
    }

    #canvas-placeholder {
        position: absolute;
        width: calc(100% - 20px);
        height: calc(100% - 20px);
        border: 4px dashed var(--shadow);
        border-radius: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
        cursor: pointer;
        color: var(--shadow);
        transition: all .2s;
        padding: 2rem;
    }
    #canvas-placeholder h3 {
        font-size: 2rem;
        margin: 0 0 0.5rem;
    }
    #canvas-placeholder:hover, #canvas-panel.drag-over #canvas-placeholder {
        border-color: var(--ink);
        color: var(--ink);
        background-color: rgba(255,255,255,0.5);
    }
    #canvas-panel.drag-over {
         background-color: var(--shadow);
    }
    #layer-instructions {
        padding: 0 0 0.5rem 0;
        margin: 0;
        font-size: 1rem;
    }

    #mg-preview-container {
        position: relative;
        background: var(--light);
        border: 2px solid var(--ink);
        box-shadow: 4px 4px 0px var(--ink);
        padding: 10px;
    }
    #mg-preview-container .overlay-close-btn {
        top: -10px;
        right: -10px;
        background: var(--danger-color);
        color: var(--light);
        border: 2px solid var(--ink);
    }
    #mg-preview-video {
        display: block;
        max-width: 80vw;
        max-height: 75vh;
        background: #000;
    }
    
    #mg-generation-overlay { z-index: 4000; }
    #mg-generation-overlay .window { max-width: 400px; height: auto; padding: 2rem; text-align: center; }
    #mg-generation-overlay h3 { font-size: 2rem; margin: 0 0 1rem; }

    #mg-confirmation-overlay { z-index: 5000; }
    #mg-confirmation-dialog {
        padding: 1.5rem;
        text-align: center;
        width: 90%;
        max-width: 400px;
        height: auto;
    }
    #mg-confirmation-dialog p {
        font-size: 1.2rem;
        margin: 0 0 1.5rem;
    }
    #mg-confirmation-dialog .action-buttons {
        display: flex;
        justify-content: center;
    }
    
    #scene-actions-container {
        grid-template-columns: 2fr 1fr 1fr;
        gap: 0.5rem;
    }
    #scene-actions-container #mg-record-layer-btn {
        font-size: 20px;
    }


    @media (max-width: 768px) {
        body {
            padding: 0;
            height: calc(var(--vh, 1vh) * 100);
            overflow: hidden;
        }
        .window {
            height: 100%;
            max-height: 100%;
            box-shadow: none;
            border: none;
        }
        #studio-container {
            grid-template-columns: 1fr;
            grid-template-rows: minmax(200px, 45%) 1fr;
            padding: 0.5rem;
            gap: 0.5rem;
            height: 100%;
        }
        #controls-panel {
            min-height: 0;
        }
        #canvas-panel {
            min-height: 0;
        }
        .mg-btn {
            padding: 12px 16px;
            font-size: 20px;
        }
        legend, #layer-instructions, .placeholder-text, #recording-status {
            font-size: 1.1rem;
        }
        .titlebar {
            font-size: 18px;
        }
        .scene-thumb {
            width: 90px;
            height: 62px;
            font-size: 1.8rem;
        }
        .palette-slot, .layer-thumb {
            width: 70px;
            height: 70px;
        }
        #mg-asset-picker-grid-wrapper {
            width: 95vw;
            max-height: 90vh;
        }
    }
</style>
</head>
<body>
<div class="window">
    <div class="titlebar">
      <span>Movie-Maker-Studio.exe</span>
      <div class="titlebar-controls">
        <button id="visuals-btn">Edit Visuals</button>
        <div id="visuals-dropdown">
            <h5>Visuals Editor</h5>
            <div id="asset-visuals-controls">
                <h6>Selected Asset</h6>
                <div class="slider-container">
                    <label for="asset-opacity">Opacity</label>
                    <input type="range" id="asset-opacity" min="0" max="1" step="0.01" value="1">
                </div>
                <div class="slider-container">
                    <label for="asset-brightness">Brightness</label>
                    <input type="range" id="asset-brightness" min="0" max="2" step="0.01" value="1">
                </div>
                <div class="slider-container">
                    <label for="asset-saturation">Saturation</label>
                    <input type="range" id="asset-saturation" min="0" max="2" step="0.01" value="1">
                </div>
            </div>
            <div id="background-visuals-controls">
                <h6>Background</h6>
                <div class="slider-container">
                    <label for="bg-brightness">Brightness</label>
                    <input type="range" id="bg-brightness" min="0" max="2" step="0.01" value="1">
                </div>
                <div class="slider-container">
                    <label for="bg-saturation">Saturation</label>
                    <input type="range" id="bg-saturation" min="0" max="2" step="0.01" value="1">
                </div>
            </div>
        </div>
        <button id="shortcuts-btn">Shortcuts</button>
        <div class="controls-fake"><div class="btn-square"></div><div class="btn-square"></div></div>
        <div id="shortcuts-dropdown">
            <h5>Keyboard Shortcuts</h5>
            <ul>
                <li><span>Start/Stop Recording</span><kbd>R</kbd></li>
                <li><span>Enlarge Asset</span><kbd>D</kbd></li>
                <li><span>Shrink Asset</span><kbd>F</kbd></li>
                <li><span>Flip Asset Horizontally</span><kbd>S</kbd></li>
                <li><span>Delete Asset</span><kbd>Delete</kbd></li>
            </ul>
        </div>
      </div>
    </div>

<main id="studio-container">
    <div id="controls-panel">
        <fieldset><legend>Scenes</legend><div id="scene-tray"></div><button class="mg-btn" id="add-scene-btn" style="margin-top: 0.5rem;" title="Add a new scene with an image or video background">+ Add Scene</button></fieldset>
        
        <fieldset>
            <legend>Layers</legend>
            <p id="layer-instructions" class="placeholder-text">
                Create a scene to begin.
            </p>
            <div id="mg-asset-palette"></div>
        </fieldset>
        
        <fieldset>
            <legend>Current Scene</legend>
            <div class="scene-controls-container">
                <div id="scene-actions-container" class="action-buttons">
                    <button class="mg-btn record" id="mg-record-layer-btn" disabled>Record Layer</button>
                    <button class="mg-btn" id="mg-preview-scene-btn" disabled>Preview Scene</button>
                    <button class="mg-btn" id="mg-delete-scene-btn" disabled>Delete Scene</button>
                </div>
                <div id="stop-actions-container" class="action-buttons hidden">
                    <button class="mg-btn active" id="mg-stop-layer-btn" style="grid-column: span 2;">Stop</button>
                </div>
                <div id="recording-status" class="hidden"><div id="recording-indicator"></div><span id="recording-timer">00:00</span></div>
                <button class="mg-btn hidden" id="mg-commit-layer-btn">Commit Layer & Add Next</button>
            </div>
        </fieldset>
         <fieldset>
            <legend>Project</legend>
            <button class="mg-btn generate" id="mg-generate-project-btn" disabled>Generate Project</button>
            <div class="action-buttons" id="post-generation-actions" style="margin-top: 0.5rem;">
                 <button class="mg-btn hidden" id="mg-preview-btn">Preview</button>
                 <button class="mg-btn hidden" id="mg-movie-download">Download</button>
            </div>
        </fieldset>
    </div>
    <div id="canvas-panel">
        <canvas id="mg-movie-canvas"></canvas>
        <canvas id="mg-controls-overlay-canvas"></canvas>
        <div id="canvas-placeholder">
            <h3>Click or Drag & Drop File</h3>
            <p>to add a background image or video</p>
        </div>
        <div id="video-volume-controls" class="hidden">
            <div id="volume-slider-wrapper">
                 <input type="range" id="video-volume-slider" min="0" max="1" step="0.05" value="1">
            </div>
            <button id="video-volume-btn">ðŸ”Š</button>
        </div>
    </div>
</main>

<input type="file" id="initial-background-input" accept="image/*,video/*" style="display:none;">
</div>
<div id="mg-asset-library-overlay" class="mg-overlay-base">
    <div id="mg-asset-picker-grid-wrapper" class="window">
        <button id="mg-asset-library-close" class="overlay-close-btn">X</button>
        <h4>Click an asset to add it to the canvas</h4>
        <div id="mg-asset-picker-grid"></div>
        <div id="mg-asset-picker-actions">
            <label class="mg-btn">Upload Custom<input type="file" id="mg-asset-picker-file" accept="image/png" style="display:none;"/></label>
        </div>
    </div>
</div>
<div id="mg-preview-popup" class="mg-overlay-base">
    <div id="mg-preview-container">
         <button id="mg-preview-close-btn" class="overlay-close-btn">X</button>
         <video id="mg-preview-video" controls autoplay></video>
    </div>
</div>
<div id="mg-generation-overlay" class="mg-overlay-base">
    <div class="window">
        <h3>Generating Project...</h3>
        <p>Please wait while your scenes are combined into the final video.</p>
    </div>
</div>
<div id="mg-confirmation-overlay" class="mg-overlay-base">
    <div id="mg-confirmation-dialog" class="window">
        <p id="mg-confirmation-text">Are you sure?</p>
        <div class="action-buttons">
            <button id="mg-confirm-yes-btn" class="mg-btn active">Yes</button>
            <button id="mg-confirm-no-btn" class="mg-btn">No</button>
        </div>
    </div>
</div>

<div id="mg-toast"></div>
<div id="mg-countdown-overlay" class="hidden"><span id="mg-countdown-span">3</span></div>
<script>
    (function () {
        // === MOBILE VIEWPORT FIX ===
        const setViewportHeight = () => {
            document.documentElement.style.setProperty('--vh', `${window.innerHeight * 0.01}px`);
        };
        window.addEventListener('resize', setViewportHeight);
        setViewportHeight(); // Initial call

        // === DOM Elements ===
        const addSceneBtn = document.getElementById('add-scene-btn');
        const assetLibraryOverlay = document.getElementById('mg-asset-library-overlay');
        const assetPalette = document.getElementById('mg-asset-palette');
        const assetPickerFileInput = document.getElementById('mg-asset-picker-file');
        const canvasPanel = document.getElementById('canvas-panel');
        const controlsPanel = document.getElementById('controls-panel');
        const canvasPlaceholder = document.getElementById('canvas-placeholder');
        const controlsOverlayCanvas = document.getElementById('mg-controls-overlay-canvas');
        const controlsCtx = controlsOverlayCanvas.getContext('2d');
        const countdownOverlay = document.getElementById('mg-countdown-overlay');
        const countdownSpan = document.getElementById('mg-countdown-span');
        const initialBackgroundInput = document.getElementById('initial-background-input');
        const layerInstructions = document.getElementById('layer-instructions');
        const movieCanvas = document.getElementById('mg-movie-canvas');
        const movieCtx = movieCanvas.getContext('2d');
        const movieDownloadBtn = document.getElementById('mg-movie-download');
        const recordLayerBtn = document.getElementById('mg-record-layer-btn');
        const stopLayerBtn = document.getElementById('mg-stop-layer-btn');
        const sceneActionsContainer = document.getElementById('scene-actions-container');
        const stopActionsContainer = document.getElementById('stop-actions-container');
        const commitLayerBtn = document.getElementById('mg-commit-layer-btn');
        const recordingStatus = document.getElementById('recording-status');
        const recordingTimer = document.getElementById('recording-timer');
        const sceneTray = document.getElementById('scene-tray');
        const newSceneBackgroundInput = document.createElement('input');
        newSceneBackgroundInput.type = 'file';
        newSceneBackgroundInput.accept = 'image/*,video/*';
        const videoVolumeControls = document.getElementById('video-volume-controls');
        const videoVolumeSlider = document.getElementById('video-volume-slider');
        const videoVolumeBtn = document.getElementById('video-volume-btn');
        const recordingCanvas = document.createElement('canvas');
        const recordingCtx = recordingCanvas.getContext('2d');
        const previewBtn = document.getElementById('mg-preview-btn');
        const previewSceneBtn = document.getElementById('mg-preview-scene-btn');
        const previewPopup = document.getElementById('mg-preview-popup');
        const previewVideo = document.getElementById('mg-preview-video');
        const generateProjectBtn = document.getElementById('mg-generate-project-btn');
        const generationOverlay = document.getElementById('mg-generation-overlay');
        const postGenerationActions = document.getElementById('post-generation-actions');
        const deleteSceneBtn = document.getElementById('mg-delete-scene-btn');
        const confirmationOverlay = document.getElementById('mg-confirmation-overlay');
        const confirmationText = document.getElementById('mg-confirmation-text');
        const confirmYesBtn = document.getElementById('mg-confirm-yes-btn');
        const confirmNoBtn = document.getElementById('mg-confirm-no-btn');
        const shortcutsBtn = document.getElementById('shortcuts-btn');
        const shortcutsDropdown = document.getElementById('shortcuts-dropdown');
        const visualsBtn = document.getElementById('visuals-btn');
        const visualsDropdown = document.getElementById('visuals-dropdown');
        const assetVisualsControls = document.getElementById('asset-visuals-controls');
        const assetOpacitySlider = document.getElementById('asset-opacity');
        const assetBrightnessSlider = document.getElementById('asset-brightness');
        const assetSaturationSlider = document.getElementById('asset-saturation');
        const bgBrightnessSlider = document.getElementById('bg-brightness');
        const bgSaturationSlider = document.getElementById('bg-saturation');
        let finalProjectUrl = null;
        let finalProjectFilename = null;


        // === State Variables ===
        const isTouchDevice = 'ontouchstart' in window;
        const DAMPING_FACTOR = 0.5;
        const RESIZE_SPEED = 1.546875; // Increased by 65% from 0.9375
        const assetCache = {};
        let scenes = [];
        let activeSceneId = null;
        let activeMovieLayerId = null;
        let movieInteraction = { active: false };
        let mediaRecorder = null;
        let recordedChunks = [];
        let isRecording = false;
        let isCountdownActive = false;
        let layerRecordingUrl = null;
        let animationFrameId = null;
        let recordingIntervalId = null;
        let recordingStartTime = 0;
        let resizeState = { isResizing: false, direction: 0, animationFrameId: null };
        let isDraggingSlider = false;

        const getCurrentScene = () => scenes.find(s => s.id === activeSceneId);
        const getActiveLayer = () => getCurrentScene()?.layers.find(l => l.id === activeMovieLayerId);

        let toastTimeoutId;
        const toast = (msg, duration = 4000) => {
            const t = document.getElementById('mg-toast');
            clearTimeout(toastTimeoutId);
            t.textContent = msg; t.style.opacity = 1; t.style.visibility = 'visible';
            if (duration !== null) {
                toastTimeoutId = setTimeout(() => { t.style.opacity = 0; t.style.visibility = 'hidden'; }, duration);
            }
        };
        
        function resetToReadyState() {
            const currentScene = getCurrentScene();
            recordLayerBtn.disabled = !currentScene || currentScene.layers.length === 0;
            recordLayerBtn.textContent = 'Record Layer';
            recordLayerBtn.classList.add('record');
            sceneActionsContainer.classList.remove('hidden');
            stopActionsContainer.classList.add('hidden');
            commitLayerBtn.classList.add('hidden');
            commitLayerBtn.classList.remove('success');

            if (layerRecordingUrl) {
                URL.revokeObjectURL(layerRecordingUrl);
                layerRecordingUrl = null;
            }
            recordedChunks = [];
        }

        function updateProjectControlsState() {
            generateProjectBtn.disabled = scenes.length === 0;
            if (finalProjectUrl) {
                URL.revokeObjectURL(finalProjectUrl);
                finalProjectUrl = null;
            }
            finalProjectFilename = null;
            previewBtn.classList.add('hidden');
            movieDownloadBtn.classList.add('hidden');
            postGenerationActions.classList.add('hidden');
        }

        function updateControlsState() {
            const hasScenes = scenes.length > 0;
            const currentScene = getCurrentScene();
            const hasLayers = currentScene && currentScene.layers.length > 0;

            addSceneBtn.disabled = isRecording;
            deleteSceneBtn.disabled = !hasScenes || isRecording;
            recordLayerBtn.disabled = !hasLayers || isRecording;
            
            const hasPreviewableContent = currentScene && (currentScene.backgroundType === 'video' || !!layerRecordingUrl);
            previewSceneBtn.disabled = !hasPreviewableContent || isRecording;
            
            updateProjectControlsState();
            renderLayerPalette();
        }

        function handleBackgroundUpload(file, mode, isFromLayerCommit = false) {
            if (!file) return;
            const fileURL = (file instanceof Blob) ? URL.createObjectURL(file) : file;

            const handleNewScene = (element, type, thumb) => {
                let sceneToUpdate;
                if (isFromLayerCommit) {
                    sceneToUpdate = getCurrentScene();
                    if (sceneToUpdate) {
                        sceneToUpdate.backgroundElement = element;
                        sceneToUpdate.backgroundType = type;
                        sceneToUpdate.thumbnail = thumb;
                        sceneToUpdate.layers = [];
                        sceneToUpdate.backgroundHistory.push(element);
                        toast('Layer committed! Add another asset to continue layering.', 4000);
                    }
                } else {
                    sceneToUpdate = { 
                        id: Date.now(), 
                        backgroundElement: element, backgroundType: type, thumbnail: thumb, 
                        layers: [],
                        originalBackgroundElement: element,
                        originalBackgroundType: type,
                        originalThumbnail: thumb,
                        committedLayerSrcs: [],
                        backgroundHistory: [element],
                        bgBrightness: 1,
                        bgSaturation: 1
                    };
                    scenes.push(sceneToUpdate);
                    if (mode === 'initial') {
                        canvasPlaceholder.classList.add('hidden');
                        toast('Background set! Add an asset to start.', 3000);
                    }
                }
                
                requestAnimationFrame(() => {
                    switchScene(sceneToUpdate.id);
                    updateControlsState();
                });
            };

            if (file.type.startsWith('image/')) {
                const img = new Image();
                img.onload = () => handleNewScene(img, 'image', img.src);
                img.onerror = () => toast('Could not load background image.');
                img.src = fileURL;
            } else if (file.type.startsWith('video/')) {
                const video = document.createElement('video');
                video.loop = !isFromLayerCommit;
                video.autoplay = false; video.muted = true; video.playsinline = true;
                
                const onSeeked = () => {
                     video.removeEventListener('seeked', onSeeked, false);
                     const thumbCanvas = document.createElement('canvas');
                     thumbCanvas.width = video.videoWidth;
                     thumbCanvas.height = video.videoHeight;
                     thumbCanvas.getContext('2d').drawImage(video, 0, 0);
                     handleNewScene(video, 'video', thumbCanvas.toDataURL('image/jpeg'));
                     video.currentTime = 0;
                     video.muted = false;
                     video.volume = videoVolumeSlider.value;
                }
                const onLoaded = () => {
                    video.removeEventListener('loadedmetadata', onLoaded, false);
                    video.currentTime = 0.1; 
                };

                video.addEventListener('loadedmetadata', onLoaded, false);
                video.addEventListener('seeked', onSeeked, false);
                video.onerror = () => toast('Could not load background video.');
                video.src = fileURL;
            } else {
                toast('Unsupported file type. Please use an image or video.');
            }
        }

        function renderSceneTray() {
            sceneTray.innerHTML = '';
            scenes.forEach((scene, index) => {
                const thumb = document.createElement('div');
                thumb.className = 'scene-thumb';
                thumb.style.backgroundImage = `url(${scene.thumbnail})`;
                thumb.classList.toggle('active', scene.id === activeSceneId);
                thumb.innerHTML = `<span>${index + 1}</span>`;
                if (scenes.length > 0) {
                    const deleteBtn = document.createElement('div');
                    deleteBtn.className = 'scene-delete-btn'; deleteBtn.innerHTML = 'x';
                    deleteBtn.onclick = (e) => { e.stopPropagation(); deleteScene(scene.id); };
                    thumb.appendChild(deleteBtn);
                }
                thumb.onclick = () => { if (scene.id !== activeSceneId && !isRecording) switchScene(scene.id); };
                sceneTray.appendChild(thumb);
            });
        }
        
        function resizeCanvas() {
            const currentScene = getCurrentScene();
            if (!currentScene) return;

            const panelWidth = canvasPanel.clientWidth;
            const panelHeight = canvasPanel.clientHeight;
            if (panelWidth === 0 || panelHeight === 0) return;

            const canvasAspectRatio = movieCanvas.width / movieCanvas.height;
            let displayWidth, displayHeight;

            if (panelWidth / panelHeight > canvasAspectRatio) {
                displayHeight = panelHeight;
                displayWidth = displayHeight * canvasAspectRatio;
            } else {
                displayWidth = panelWidth;
                displayHeight = displayWidth / canvasAspectRatio;
            }

            [movieCanvas, controlsOverlayCanvas].forEach(c => {
                c.style.width = `${displayWidth}px`;
                c.style.height = `${displayHeight}px`;
            });
        }


        function switchScene(sceneId) {
            stopAnimationLoop();
            activeSceneId = sceneId;
            const currentScene = getCurrentScene(); if (!currentScene) return;
            activeMovieLayerId = null;

            const bg = currentScene.backgroundElement;
            const w = bg.naturalWidth || bg.videoWidth;
            const h = bg.naturalHeight || bg.videoHeight;
            
            let aspectRatio = w / h;
            if (!isFinite(aspectRatio) || aspectRatio === 0) {
                aspectRatio = 16 / 9;
            }

            const qualityWidth = 1920;
            movieCanvas.width = controlsOverlayCanvas.width = qualityWidth;
            movieCanvas.height = controlsOverlayCanvas.height = qualityWidth / aspectRatio;

            resizeCanvas();

            if (currentScene.backgroundType === 'video') {
                videoVolumeControls.classList.remove('hidden');
                currentScene.backgroundElement.volume = videoVolumeSlider.value;
            } else {
                videoVolumeControls.classList.add('hidden');
                videoVolumeControls.classList.remove('open');
            }

            renderSceneTray();
            renderLayerPalette();
            drawControlsOverlay();
            resetToReadyState();
            updateControlsState();
            updateVisualsUI();
            startAnimationLoop();
        }

        function deleteScene(sceneIdToDelete) {
            if (scenes.length === 0) return;
            const sceneIndex = scenes.findIndex(s => s.id === sceneIdToDelete);
            
            if (scenes.length === 1) {
                clearProject();
                return;
            }

            scenes.splice(sceneIndex, 1);
            if (activeSceneId === sceneIdToDelete) {
                const newActiveIndex = Math.max(0, sceneIndex - 1);
                switchScene(scenes[newActiveIndex].id);
            } else {
                renderSceneTray();
            }
            updateControlsState();
        }

        function populateAssetLibraryGrid() {
            document.getElementById('mg-asset-picker-grid').innerHTML = '';
            const addAssetFromLibrary = (src) => {
                const currentScene = getCurrentScene();
                if(!currentScene) { toast('Please add a background to the scene first.'); return; }
                if(currentScene.layers.length >= 1) { toast('Only one asset can be animated at a time in this mode.'); return; }
                addMovieLayer(src);
                closeAssetLibrary();
            };
            Array.from({length: 107}, (_, i) => i + 1).forEach(i => {
                const src = `./assets/maker/${i}.png`;
                const div = document.createElement('div');
                div.className = 'mg-template';
                div.innerHTML = `<img src="${src}" alt="Asset ${i}">`;
                div.addEventListener('click', () => addAssetFromLibrary(src));
                document.getElementById('mg-asset-picker-grid').appendChild(div);
            });
        }

        function openAssetLibrary() {
            populateAssetLibraryGrid();
            assetLibraryOverlay.classList.add('visible');
        }
        function closeAssetLibrary() { assetLibraryOverlay.classList.remove('visible'); }
        
        function updateLayerInstructions() {
            const currentScene = getCurrentScene();
            layerInstructions.classList.remove('placeholder-text');

            if (!currentScene) {
                layerInstructions.textContent = "Create a scene to begin.";
                layerInstructions.classList.add('placeholder-text');
                return;
            }
            
            const hasActiveLayer = currentScene.layers.length > 0;
            const hasCommittedLayers = currentScene.committedLayerSrcs.length > 0;

            if (hasActiveLayer) {
                layerInstructions.textContent = "Click 'Record Layer' to animate it, then 'Stop'.";
            } else if (hasCommittedLayers) {
                 layerInstructions.textContent = "Add another asset to continue layering on this scene.";
            } else {
                 layerInstructions.textContent = "Add one asset, click 'Record Layer' to animate it, then 'Stop'. Then use the 'Commit Layer' button to continue animating your scene.";
            }
        }

        function renderLayerPalette() {
            assetPalette.innerHTML = '';
            updateLayerInstructions();

            const currentScene = getCurrentScene();
            if (!currentScene) return;

            currentScene.committedLayerSrcs.forEach((src, index) => {
                const thumb = document.createElement('div');
                thumb.className = 'layer-thumb locked';
                thumb.title = "This layer is committed. Click X to revert.";
                thumb.innerHTML = `<img src="${src}"><div class="layer-controls"><div class="layer-btn delete" title="Delete this committed layer and subsequent layers">x</div></div>`;
                thumb.querySelector('.delete').onclick = (e) => { e.stopPropagation(); deleteCommittedLayer(index); };
                assetPalette.appendChild(thumb);
            });

            const activeLayer = currentScene.layers[0];
            if (activeLayer) {
                 const thumb = document.createElement('div');
                 thumb.className = 'layer-thumb';
                 thumb.classList.toggle('active', activeLayer.id === activeMovieLayerId);
                 thumb.dataset.layerId = activeLayer.id;
                 thumb.title = "Click to select";
                 thumb.innerHTML = `<img src="${activeLayer.src}"><div class="layer-controls"><div class="layer-btn delete" title="Delete Layer">x</div></div>`;
                 thumb.addEventListener('click', (e) => {
                     if (e.target.classList.contains('layer-btn')) return;
                     activeMovieLayerId = activeLayer.id;
                     renderLayerPalette();
                     drawControlsOverlay();
                 });
                 thumb.querySelector('.delete').onclick = (e) => { e.stopPropagation(); deleteMovieLayer(activeLayer.id); };
                 assetPalette.appendChild(thumb);
            } else if(currentScene.committedLayerSrcs.length < 8) {
                const emptySlot = document.createElement('div');
                emptySlot.className = 'palette-slot empty';
                emptySlot.innerHTML = '+';
                emptySlot.title = "Add a new asset to animate";
                emptySlot.onclick = openAssetLibrary;
                assetPalette.appendChild(emptySlot);
            }
        }

        function deleteCommittedLayer(indexToDelete) {
            const scene = getCurrentScene();
            if (!scene) return;

            const backgroundToRestore = scene.backgroundHistory[indexToDelete];

            scene.backgroundElement = backgroundToRestore;
            scene.backgroundType = (backgroundToRestore.tagName === 'VIDEO') ? 'video' : 'image';
            
            scene.backgroundHistory.splice(indexToDelete + 1);
            scene.committedLayerSrcs.splice(indexToDelete);

            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = backgroundToRestore.naturalWidth || backgroundToRestore.videoWidth;
            thumbCanvas.height = backgroundToRestore.naturalHeight || backgroundToRestore.videoHeight;
            thumbCanvas.getContext('2d').drawImage(backgroundToRestore, 0, 0);
            scene.thumbnail = thumbCanvas.toDataURL('image/jpeg');

            switchScene(scene.id);
            toast('Layer reverted.', 2000);
        }

        function updateVisualsUI() {
            const currentScene = getCurrentScene();
            const activeLayer = getActiveLayer();

            if (!currentScene) {
                assetVisualsControls.classList.add('disabled');
                bgBrightnessSlider.value = 1;
                bgSaturationSlider.value = 1;
                assetOpacitySlider.value = 1;
                assetBrightnessSlider.value = 1;
                assetSaturationSlider.value = 1;
                return;
            };

            if (activeLayer) {
                assetVisualsControls.classList.remove('disabled');
                assetOpacitySlider.value = activeLayer.opacity;
                assetBrightnessSlider.value = activeLayer.brightness;
                assetSaturationSlider.value = activeLayer.saturation;
            } else {
                assetVisualsControls.classList.add('disabled');
                assetOpacitySlider.value = 1;
                assetBrightnessSlider.value = 1;
                assetSaturationSlider.value = 1;
            }

            bgBrightnessSlider.value = currentScene.bgBrightness;
            bgSaturationSlider.value = currentScene.bgSaturation;
        }


        function addMovieLayer(src, properties = {}) {
            const currentScene = getCurrentScene();
            if (!currentScene) { toast('Add a background first.'); return; }
            if (currentScene.layers.length >= 1) { toast('Only one asset can be animated at a time.'); return; }

            const createLayer = (img) => {
                const newLayer = { 
                    id: Date.now() + Math.random(), src, img, 
                    x: properties.x || movieCanvas.width / 2, 
                    y: properties.y || movieCanvas.height / 2, 
                    size: properties.size || movieCanvas.width * 0.25, 
                    rot: properties.rot || 0, 
                    flipX: false,
                    opacity: 1,
                    brightness: 1,
                    saturation: 1
                };
                currentScene.layers.push(newLayer);
                activeMovieLayerId = newLayer.id;
                renderLayerPalette();
                updateControlsState();
                updateVisualsUI();
                drawMovieFrame();
                drawControlsOverlay();
                toast('Asset Added! Ready to record.', 3000);
            };
            if (assetCache[src]) {
                createLayer(assetCache[src]);
            } else {
                const image = new Image();
                image.onload = () => { assetCache[src] = image; createLayer(image); };
                image.onerror = () => toast(`Could not load asset: ${src}`);
                image.src = src;
            }
        }

        function deleteMovieLayer(layerId) {
            const currentScene = getCurrentScene(); if (!currentScene) return;
            currentScene.layers = currentScene.layers.filter(l => l.id !== layerId);
            if (activeMovieLayerId === layerId) activeMovieLayerId = null;
            renderLayerPalette();
            updateControlsState();
            updateVisualsUI();
            drawMovieFrame();
            drawControlsOverlay();
        }
        
        function drawMovieFrame() {
            const currentScene = getCurrentScene();
            if (!currentScene || !currentScene.backgroundElement) {
                movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
                return;
            }

            if (movieInteraction.active && movieInteraction.type === 'drag' && !movieInteraction.primed) {
                const l = currentScene.layers.find(layer => layer.id === movieInteraction.layerId);
                if (l) {
                    const dx = movieInteraction.targetX - l.x;
                    const dy = movieInteraction.targetY - l.y;
                    if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                        l.x += dx * DAMPING_FACTOR;
                        l.y += dy * DAMPING_FACTOR;
                    } else {
                        l.x = movieInteraction.targetX;
                        l.y = movieInteraction.targetY;
                    }
                }
            }

            const { backgroundElement, layers: movieLayers, bgBrightness, bgSaturation } = currentScene;

            movieCtx.clearRect(0, 0, movieCanvas.width, movieCanvas.height);
            movieCtx.save();
            movieCtx.filter = `brightness(${bgBrightness}) saturate(${bgSaturation})`;
            movieCtx.drawImage(backgroundElement, 0, 0, movieCanvas.width, movieCanvas.height);
            movieCtx.restore();

            movieLayers.forEach(l => {
                if (l.img && l.img.complete) {
                    const dWidth = l.size; const dHeight = l.size * (l.img.naturalHeight / l.img.naturalWidth);
                    movieCtx.save();
                    movieCtx.globalAlpha = l.opacity;
                    movieCtx.filter = `brightness(${l.brightness}) saturate(${l.saturation})`;
                    movieCtx.translate(l.x, l.y);
                    movieCtx.rotate(l.rot * Math.PI / 180);
                    if (l.flipX) {
                        movieCtx.scale(-1, 1);
                    }
                    movieCtx.drawImage(l.img, -dWidth / 2, -dHeight / 2, dWidth, dHeight);
                    movieCtx.restore();
                }
            });


            if (isRecording) {
                const bg = backgroundElement;
                const bgWidth = bg.naturalWidth || bg.videoWidth;
                const bgHeight = bg.naturalHeight || bg.videoHeight;
                if(bgWidth === 0 || bgHeight === 0) return;

                recordingCtx.clearRect(0, 0, recordingCanvas.width, recordingCanvas.height);
                
                const bgRatio = bgWidth / bgHeight;
                const recRatio = recordingCanvas.width / recordingCanvas.height;
                let drawWidth, drawHeight, drawX, drawY;

                if (bgRatio > recRatio) {
                    drawHeight = recordingCanvas.height;
                    drawWidth = drawHeight * bgRatio;
                    drawX = (recordingCanvas.width - drawWidth) / 2;
                    drawY = 0;
                } else {
                    drawWidth = recordingCanvas.width;
                    drawHeight = drawWidth / bgRatio;
                    drawY = (recordingCanvas.height - drawHeight) / 2;
                    drawX = 0;
                }
                
                recordingCtx.save();
                recordingCtx.filter = `brightness(${bgBrightness}) saturate(${bgSaturation})`;
                recordingCtx.drawImage(bg, drawX, drawY, drawWidth, drawHeight);
                recordingCtx.restore();

                const previewCanvasWidth = movieCanvas.width;
                const previewCanvasHeight = movieCanvas.height;
                movieLayers.forEach(l => {
                    if (l.img && l.img.complete) {
                        const percentX = l.x / previewCanvasWidth;
                        const percentY = l.y / previewCanvasHeight; 
                        const percentSize = l.size / previewCanvasWidth;

                        const finalX = drawX + (percentX * drawWidth);
                        const finalY = drawY + (percentY * drawHeight);
                        const finalSize = percentSize * drawWidth;

                        const dWidth = finalSize;
                        const dHeight = finalSize * (l.img.naturalHeight / l.img.naturalWidth);

                        recordingCtx.save();
                        recordingCtx.globalAlpha = l.opacity;
                        recordingCtx.filter = `brightness(${l.brightness}) saturate(${l.saturation})`;
                        recordingCtx.translate(finalX, finalY);
                        recordingCtx.rotate(l.rot * Math.PI / 180);
                        if (l.flipX) {
                            recordingCtx.scale(-1, 1);
                        }
                        recordingCtx.drawImage(l.img, -dWidth / 2, -dHeight / 2, dWidth, dHeight);
                        recordingCtx.restore();
                    }
                });
            }
        }


        function drawControlsOverlay() {
            controlsCtx.clearRect(0, 0, controlsOverlayCanvas.width, controlsOverlayCanvas.height);
            const currentScene = getCurrentScene();
            if (!currentScene) return;

            const activeLayer = currentScene.layers.find(l => l.id === activeMovieLayerId);
            if (activeLayer) {
                const HANDLE_SIZE = isTouchDevice ? 32 : 16;
                const dWidth = activeLayer.size; const dHeight = activeLayer.size * (activeLayer.img.naturalHeight / activeLayer.img.naturalWidth);
                const ho = HANDLE_SIZE / 2; const ROTATION_HANDLE_OFFSET = isTouchDevice ? 40 : 30;
                controlsCtx.save();
                controlsCtx.translate(activeLayer.x, activeLayer.y);
                controlsCtx.rotate(activeLayer.rot * Math.PI / 180);
                controlsCtx.strokeStyle = '#00FF00'; controlsCtx.lineWidth = 2;
                controlsCtx.strokeRect(-dWidth / 2, -dHeight / 2, dWidth, dHeight);
                controlsCtx.fillStyle = '#00FF00';
                controlsCtx.fillRect(-dWidth/2-ho, -dHeight/2-ho, HANDLE_SIZE, HANDLE_SIZE);
                controlsCtx.fillRect(dWidth/2-ho, -dHeight/2-ho, HANDLE_SIZE, HANDLE_SIZE);
                controlsCtx.fillRect(-dWidth/2-ho, dHeight/2-ho, HANDLE_SIZE, HANDLE_SIZE);
                controlsCtx.fillRect(dWidth/2-ho, dHeight/2-ho, HANDLE_SIZE, HANDLE_SIZE);
                controlsCtx.beginPath(); controlsCtx.moveTo(0, -dHeight / 2);
                controlsCtx.lineTo(0, -dHeight / 2 - ROTATION_HANDLE_OFFSET);
                controlsCtx.stroke(); controlsCtx.beginPath();
                controlsCtx.arc(0, -dHeight / 2 - ROTATION_HANDLE_OFFSET, HANDLE_SIZE / 2, 0, 2 * Math.PI);
                controlsCtx.fill(); controlsCtx.restore();
            }
        }

        function animationLoop() {
            drawMovieFrame();
            drawControlsOverlay();
            animationFrameId = requestAnimationFrame(animationLoop);
        }
        function startAnimationLoop() { if (!animationFrameId) animationLoop(); }
        function stopAnimationLoop() { cancelAnimationFrame(animationFrameId); animationFrameId = null; }

        function updateTimer() {
            const elapsed = Math.floor((Date.now() - recordingStartTime) / 1000);
            recordingTimer.textContent = `${String(Math.floor(elapsed/60)).padStart(2,'0')}:${String(elapsed%60).padStart(2,'0')}`;
        }

        function runCountdown(onComplete) {
            isCountdownActive = true;
            let count = 3;
            countdownSpan.textContent = count;
            countdownOverlay.classList.remove('hidden');
            const intervalId = setInterval(() => {
                count--;
                if (count > 0) { countdownSpan.textContent = count; }
                else { 
                    clearInterval(intervalId); 
                    countdownOverlay.classList.add('hidden');
                    isCountdownActive = false;
                    if (movieInteraction.active && movieInteraction.primed) {
                        movieInteraction.primed = false; 
                    }
                    onComplete(); 
                }
            }, 1000);
        }

        function startMovieRecording() {
            const currentScene = getCurrentScene();
            if (!currentScene || currentScene.layers.length === 0) {
                 toast('Please add an asset to the scene first.', 2000);
                 return;
            }
            if (!activeMovieLayerId) {
                toast('Please select the asset you want to animate.', 2500);
                return;
            }
            
            resetToReadyState(); 

            const bg = currentScene.backgroundElement;
            recordingCanvas.width = bg.naturalWidth || bg.videoWidth;
            recordingCanvas.height = bg.naturalHeight || bg.videoHeight;

            sceneActionsContainer.classList.add('hidden');
            stopActionsContainer.classList.remove('hidden');
            recordingStatus.classList.remove('hidden');
            updateControlsState();
            startAnimationLoop();
            
            runCountdown(() => {
                isRecording = true;
                if (movieInteraction.active && movieInteraction.primed) {
                    movieInteraction.primed = false;
                }
                recordingStartTime = Date.now();
                recordingIntervalId = setInterval(updateTimer, 1000);
                
                const canvasStream = recordingCanvas.captureStream(30);
                if (currentScene?.backgroundType === 'video') {
                    const videoElement = currentScene.backgroundElement;
                    videoElement.currentTime = 0;
                    videoElement.volume = videoVolumeSlider.value;
                    let audioStream;
                    if (videoElement.captureStream) audioStream = videoElement.captureStream();
                    else if (videoElement.mozCaptureStream) audioStream = videoElement.mozCaptureStream();
                    if (audioStream && audioStream.getAudioTracks().length > 0) {
                        canvasStream.addTrack(audioStream.getAudioTracks()[0]);
                    }
                }
                
                const hasAudioTrack = canvasStream.getAudioTracks().length > 0;
                let mimeType;
                if (MediaRecorder.isTypeSupported('video/mp4')) {
                    mimeType = 'video/mp4';
                } else {
                    mimeType = hasAudioTrack ? 'video/webm; codecs=vp9,opus' : 'video/webm; codecs=vp9';
                }

                mediaRecorder = new MediaRecorder(canvasStream, { mimeType });
                mediaRecorder.ondataavailable = (e) => { if (e.data.size > 0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: mimeType });
                    layerRecordingUrl = URL.createObjectURL(blob);
                    commitLayerBtn.classList.remove('hidden');
                    commitLayerBtn.classList.add('success');
                    updateControlsState();
                };
                mediaRecorder.start();

                if (currentScene && currentScene.backgroundType === 'video') {
                    currentScene.backgroundElement.play();
                }
                toast('Recording started!', 2000);
            });
        }
        
        function stopMovieRecording() {
            movieInteraction.active = false;
            const currentScene = getCurrentScene();

            stopActionsContainer.classList.add('hidden');
            recordingTimer.textContent = 'Finalizing...';
            toast('Finalizing recording, please wait...', null);

            if (currentScene?.backgroundType === 'video') {
                currentScene.backgroundElement.pause();
                currentScene.backgroundElement.currentTime = 0;
            }

            if (mediaRecorder?.state !== 'inactive') {
                mediaRecorder.stop();
            }

            isRecording = false;

            sceneActionsContainer.classList.remove('hidden');
            recordLayerBtn.textContent = 'Re-record Layer';
            recordLayerBtn.classList.remove('record');
            recordingStatus.classList.add('hidden');
            clearInterval(recordingIntervalId);
            recordingTimer.textContent = '00:00';

            toast('Layer recorded successfully! Commit it to add another layer.', 4000);
            updateControlsState();
        }

        function previewCurrentScene() {
            if (isRecording) return;
            const currentScene = getCurrentScene();
            if (!currentScene) {
                toast('No active scene to preview.', 2000);
                return;
            }

            let previewUrl = null;
            let videoElementToPlay = null;

            if (layerRecordingUrl) {
                previewUrl = layerRecordingUrl;
            } else if (currentScene.backgroundType === 'video') {
                videoElementToPlay = currentScene.backgroundElement;
            }

            if (previewUrl) {
                previewVideo.src = previewUrl;
                previewVideo.currentTime = 0; 
                previewPopup.classList.add('visible');
                previewVideo.play();
            } else if (videoElementToPlay) {
                videoElementToPlay.currentTime = 0; 
                previewVideo.src = videoElementToPlay.src;
                previewPopup.classList.add('visible');
                previewVideo.play();
            } else {
                toast('No video content to preview for this scene.', 2000);
            }
        }
        
        async function generateFinalMovie() {
            if(isRecording) {
                toast('Please stop the current recording before generating.', 3000);
                return;
            }
            generationOverlay.classList.add('visible');
            const finalChunks = [];
            const masterWidth = scenes[0].backgroundElement.naturalWidth || scenes[0].backgroundElement.videoWidth;
            const masterHeight = scenes[0].backgroundElement.naturalHeight || scenes[0].backgroundElement.videoHeight;
            
            recordingCanvas.width = masterWidth;
            recordingCanvas.height = masterHeight;

            const finalStream = recordingCanvas.captureStream(30);
            const hasAudio = scenes.some(s => s.backgroundType === 'video');

            let mimeType;
            if (MediaRecorder.isTypeSupported('video/mp4')) {
                mimeType = 'video/mp4';
                toast('Generating MP4 file...', null);
            } else {
                mimeType = hasAudio ? 'video/webm; codecs=vp9,opus' : 'video/webm; codecs=vp9';
                toast('MP4 not supported, generating WebM file...', null);
            }

            const finalRecorder = new MediaRecorder(finalStream, { mimeType });
            
            finalRecorder.ondataavailable = e => { if (e.data.size > 0) finalChunks.push(e.data); };

            const generationPromise = new Promise(resolve => {
                finalRecorder.onstop = () => {
                    const finalBlob = new Blob(finalChunks, { type: mimeType });
                    finalProjectUrl = URL.createObjectURL(finalBlob);
                    
                    const extension = mimeType.startsWith('video/mp4') ? 'mp4' : 'webm';
                    finalProjectFilename = `movie-maker-masterpiece.${extension}`;

                    generationOverlay.classList.remove('visible');
                    toast('Project generation complete! You can now preview or download.', 4000);
                    previewBtn.classList.remove('hidden');
                    movieDownloadBtn.classList.remove('hidden');
                    postGenerationActions.classList.remove('hidden');

                    controlsPanel.scrollTo({
                        top: controlsPanel.scrollHeight,
                        behavior: 'smooth'
                    });

                    resolve();
                };
            });

            finalRecorder.start();
            
            const renderSceneFrame = (scene) => {
                recordingCtx.clearRect(0, 0, masterWidth, masterHeight);
                recordingCtx.save();
                recordingCtx.filter = `brightness(${scene.bgBrightness}) saturate(${scene.bgSaturation})`;
                recordingCtx.drawImage(scene.backgroundElement, 0, 0, masterWidth, masterHeight);
                recordingCtx.restore();
            }

            for (const scene of scenes) {
                const bg = scene.backgroundElement;
                if (scene.backgroundType === 'video') {
                    await new Promise(sceneResolve => {
                        bg.loop = false;
                        bg.currentTime = 0;
                        bg.muted = !hasAudio;
                        
                        let sceneAnimFrame;
                        const videoAnimLoop = () => {
                            if (bg.paused || bg.ended) {
                                cancelAnimationFrame(sceneAnimFrame);
                                return;
                            }
                            renderSceneFrame(scene);
                            sceneAnimFrame = requestAnimationFrame(videoAnimLoop);
                        };
                        
                        const onEnded = () => {
                            bg.removeEventListener('ended', onEnded, false);
                            bg.loop = true;
                            sceneResolve();
                        };
                        bg.addEventListener('ended', onEnded, false);

                        bg.play().then(videoAnimLoop).catch(e => {
                            console.error("Playback error:", e);
                            sceneResolve();
                        });
                    });
                } else {
                    await new Promise(sceneResolve => {
                        const STATIC_DURATION_MS = 3000;
                        renderSceneFrame(scene);
                        setTimeout(sceneResolve, STATIC_DURATION_MS);
                    });
                }
            }

            finalRecorder.stop();
            return generationPromise;
        }


        // --- Interaction Logic ---
        function getMovieCanvasPoint(e) {
            const rect = movieCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: (clientX - rect.left) / rect.width * movieCanvas.width, y: (clientY - rect.top) / rect.height * movieCanvas.height };
        }
        function getMovieHandleAtPoint(point, layer) {
            const l = layer; const dWidth = l.size; const dHeight = l.size * (l.img.naturalHeight / l.img.naturalWidth);
            const radius = isTouchDevice ? 40 : 20;
            const angle = l.rot * Math.PI / 180; const cos = Math.cos(angle); const sin = Math.sin(angle);
            const ROTATION_HANDLE_OFFSET = isTouchDevice ? 40 : 30;
            const rotHandleY = -dHeight / 2 - ROTATION_HANDLE_OFFSET;
            const rotHandleWorldX = l.x - (rotHandleY * sin); const rotHandleWorldY = l.y + (rotHandleY * cos);
            if (Math.hypot(point.x - rotHandleWorldX, point.y - rotHandleWorldY) < radius) return 'rotate';
            const handles = { tl: { x: -dWidth / 2, y: -dHeight / 2 }, tr: { x:  dWidth / 2, y: -dHeight / 2 }, bl: { x: -dWidth / 2, y:  dHeight / 2 }, br: { x:  dWidth / 2, y:  dHeight / 2 } };
            for (const name in handles) {
                const h = handles[name];
                const handleWorldX = l.x + h.x * cos - h.y * sin; const handleWorldY = l.y + h.x * sin + h.y * cos;
                if (Math.hypot(point.x - handleWorldX, point.y - handleWorldY) < radius) return name;
            }
            return null;
        }
        function isPointInMovieLayer(point, layer) {
            const l = layer; const dWidth = l.size; const dHeight = l.size * (l.img.naturalHeight / l.img.naturalWidth);
            const dx = point.x - l.x; const dy = point.y - l.y; const angle = -l.rot * Math.PI / 180;
            const localX = dx * Math.cos(angle) - dy * Math.sin(angle); const localY = dx * Math.sin(angle) + dy * Math.cos(angle);
            return (Math.abs(localX) < dWidth / 2 && Math.abs(localY) < dHeight / 2);
        }

        function handleMovieInteractionStart(e) {
            e.preventDefault();
            const point = getMovieCanvasPoint(e);
            const currentScene = getCurrentScene();
            if (!currentScene) return;

            const activeLayer = currentScene.layers.find(l => l.id === activeMovieLayerId);

            if (activeLayer) {
                const handle = getMovieHandleAtPoint(point, activeLayer);
                if (handle) {
                    movieInteraction = { active: true, type: handle === 'rotate' ? 'rotate' : 'resize', layerId: activeLayer.id, handle, startX: point.x, startY: point.y, initialState: JSON.parse(JSON.stringify(activeLayer)) };
                    startAnimationLoop();
                    return;
                }
            }
            
            let layerChanged = false;
            for (let i = currentScene.layers.length - 1; i >= 0; i--) {
                const l = currentScene.layers[i];
                if (isPointInMovieLayer(point, l)) {
                    if (activeMovieLayerId !== l.id) {
                        activeMovieLayerId = l.id;
                        layerChanged = true;
                        renderLayerPalette();
                        drawControlsOverlay();
                    }
                    movieInteraction = {
                        active: true, type: 'drag', layerId: l.id,
                        offsetX: point.x - l.x,
                        offsetY: point.y - l.y,
                        targetX: l.x,
                        targetY: l.y,
                        primed: isCountdownActive
                    };
                    startAnimationLoop();
                    if(layerChanged) updateVisualsUI();
                    return;
                }
            }

            if (activeMovieLayerId) {
                 activeMovieLayerId = null;
                 renderLayerPalette();
                 drawControlsOverlay();
                 updateVisualsUI();
            }
        }

        function handleMovieInteractionMove(e) {
            if (!movieInteraction.active) { updateCursor(e); return; }
            e.preventDefault();
            const point = getMovieCanvasPoint(e);
            const l = getCurrentScene()?.layers.find(layer => layer.id === movieInteraction.layerId); if (!l) return;

            if (movieInteraction.type === 'drag') {
                movieInteraction.targetX = point.x - movieInteraction.offsetX;
                movieInteraction.targetY = point.y - movieInteraction.offsetY;
            } else if (movieInteraction.type === 'resize') {
                const iState = movieInteraction.initialState;
                const initialDist = Math.hypot(movieInteraction.startX - iState.x, movieInteraction.startY - iState.y);
                const currentDist = Math.hypot(point.x - iState.x, point.y - iState.y);
                if (initialDist > 1) { l.size = Math.max(20, iState.size * (currentDist / initialDist)); }
            } else if (movieInteraction.type === 'rotate') {
                const iState = movieInteraction.initialState;
                const initialAngle = Math.atan2(movieInteraction.startY - iState.y, movieInteraction.startX - iState.x) * 180 / Math.PI;
                const currentAngle = Math.atan2(point.y - iState.y, point.x - iState.x) * 180 / Math.PI;
                l.rot = iState.rot + (currentAngle - initialAngle);
            }
        }
        function handleMovieInteractionEnd(e) {
            movieInteraction.active = false;
        }

        function updateCursor(e) {
            const point = getMovieCanvasPoint(e);
            const currentScene = getCurrentScene(); if (!currentScene) return;
            let newCursor = 'default';
            const activeLayer = currentScene.layers.find(l => l.id === activeMovieLayerId);
            if (activeLayer) {
                const handle = getMovieHandleAtPoint(point, activeLayer);
                if (handle) {
                    newCursor = handle === 'rotate' ? 'grab' : (handle === 'tl' || handle === 'br' ? 'nwse-resize' : 'nesw-resize');
                } else if (isPointInMovieLayer(point, activeLayer)) {
                    newCursor = 'move';
                }
            }
            if (newCursor === 'default') {
                 for (let i = currentScene.layers.length - 1; i >= 0; i--) {
                     if (isPointInMovieLayer(point, currentScene.layers[i])) {
                         newCursor = 'pointer'; break;
                     }
                 }
            }
            movieCanvas.style.cursor = newCursor;
        }

        function continuousResizeLoop() {
            if (!resizeState.isResizing) return;
            const activeLayer = getCurrentScene()?.layers.find(l => l.id === activeMovieLayerId);
            if (activeLayer) {
                activeLayer.size = Math.max(20, activeLayer.size + RESIZE_SPEED * resizeState.direction);
            }
            resizeState.animationFrameId = requestAnimationFrame(continuousResizeLoop);
        }

        function handleKeyDown(e) {
            const key = e.key.toLowerCase();
            if (document.activeElement.tagName === 'INPUT') return;
            
            const activeLayer = getCurrentScene()?.layers.find(l => l.id === activeMovieLayerId);
            
            if (key === 'r') {
                e.preventDefault();
                if (isRecording) {
                    stopMovieRecording();
                } else if (!recordLayerBtn.disabled) {
                    startMovieRecording();
                }
                return;
            }

            if (!activeLayer) return;

            if (key === 's') {
                e.preventDefault();
                activeLayer.flipX = !activeLayer.flipX;
            } else if (key === 'd' || key === 'f') {
                e.preventDefault();
                if (resizeState.isResizing) return; // Prevent multiple loops
                resizeState.isResizing = true;
                resizeState.direction = (key === 'd') ? 1 : -1;
                continuousResizeLoop();
            } else if (!isRecording) {
                switch (key) {
                    case 'delete': case 'backspace':
                        e.preventDefault(); deleteMovieLayer(activeLayer.id); toast('Layer deleted', 2000); break;
                }
            }
        }

        function handleKeyUp(e) {
            const key = e.key.toLowerCase();
            if (key === 'd' || key === 'f') {
                e.preventDefault();
                resizeState.isResizing = false;
                cancelAnimationFrame(resizeState.animationFrameId);
            }
        }
        
        function clearProject() {
            scenes = [];
            activeSceneId = null;
            activeMovieLayerId = null;
            
            movieCtx.clearRect(0,0,movieCanvas.width, movieCanvas.height);
            controlsCtx.clearRect(0,0,controlsOverlayCanvas.width, controlsOverlayCanvas.height);
            canvasPlaceholder.classList.remove('hidden');
            sceneTray.innerHTML = '';
            
            updateControlsState();
            updateVisualsUI();
            toast("Project cleared.", 2000);
        }

        let confirmCallback = null;
        function openConfirmationModal(text, onConfirm) {
            confirmationText.textContent = text;
            confirmCallback = onConfirm;
            confirmationOverlay.classList.add('visible');
        }
        function closeConfirmationModal() {
            confirmationOverlay.classList.remove('visible');
            confirmCallback = null;
        }
        
        const setupEventListeners = () => {
            const setValNull = e => e.target.value = null;
            initialBackgroundInput.addEventListener('change', e => { handleBackgroundUpload(e.target.files[0], 'initial'); setValNull(e); });
            
            addSceneBtn.addEventListener('click', () => {
                if (scenes.length === 0) {
                    initialBackgroundInput.click();
                } else {
                    newSceneBackgroundInput.click();
                }
            });

            newSceneBackgroundInput.addEventListener('change', e => { handleBackgroundUpload(e.target.files[0], 'add'); setValNull(e); });
            
            document.getElementById('mg-asset-library-close').addEventListener('click', closeAssetLibrary);
            assetLibraryOverlay.addEventListener('click', (e) => { if (e.target === assetLibraryOverlay) closeAssetLibrary(); });
            assetPickerFileInput.addEventListener('change', e => {
                const file = e.target.files[0]; if (!file) return;
                if (!file.type.startsWith('image/')) { toast('Invalid file type, please use PNG.'); setValNull(e); return; }
                const reader = new FileReader();
                reader.onload = () => {
                    addMovieLayer(reader.result)
                    closeAssetLibrary();
                };
                reader.readAsDataURL(file); setValNull(e);
            });
            recordLayerBtn.addEventListener('click', startMovieRecording);
            stopLayerBtn.addEventListener('click', stopMovieRecording);
            previewSceneBtn.addEventListener('click', previewCurrentScene);
            commitLayerBtn.addEventListener('click', () => {
                if (layerRecordingUrl) {
                    const currentScene = getCurrentScene();
                    if (currentScene && currentScene.layers[0]) {
                        currentScene.committedLayerSrcs.push(currentScene.layers[0].src);
                    }
                    fetch(layerRecordingUrl).then(res => res.blob()).then(blob => {
                        handleBackgroundUpload(blob, '', true);
                    });
                }
            });
            generateProjectBtn.addEventListener('click', generateFinalMovie);
            movieDownloadBtn.addEventListener('click', () => {
                if (finalProjectUrl) {
                    const link = document.createElement('a');
                    link.href = finalProjectUrl;
                    link.download = finalProjectFilename || 'movie-maker-masterpiece.mp4';
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                } else toast('No final project available.', 2000);
            });

            previewBtn.addEventListener('click', () => {
                if(finalProjectUrl) {
                    previewVideo.src = finalProjectUrl;
                    previewVideo.currentTime = 0;
                    previewPopup.classList.add('visible');
                }
            });
            document.getElementById('mg-preview-close-btn').addEventListener('click', () => {
                previewVideo.pause();
                previewPopup.classList.remove('visible');
            });

            deleteSceneBtn.addEventListener('click', () => {
                const text = "This will permanently delete the current scene. Are you sure?";
                openConfirmationModal(text, () => {
                    deleteScene(activeSceneId);
                    closeConfirmationModal();
                });
            });
            confirmYesBtn.addEventListener('click', () => { if(confirmCallback) confirmCallback(); });
            confirmNoBtn.addEventListener('click', closeConfirmationModal);
            confirmationOverlay.addEventListener('click', closeConfirmationModal);
            document.getElementById('mg-confirmation-dialog').addEventListener('click', e => e.stopPropagation());

            movieCanvas.addEventListener('mousedown', handleMovieInteractionStart);
            window.addEventListener('mousemove', handleMovieInteractionMove);
            window.addEventListener('mouseup', handleMovieInteractionEnd);
            movieCanvas.addEventListener('mouseleave', () => { if (!movieInteraction.active) { movieCanvas.style.cursor = 'default'; }});
            movieCanvas.addEventListener('touchstart', handleMovieInteractionStart, { passive: false });
            window.addEventListener('touchmove', handleMovieInteractionMove, { passive: false });
            window.addEventListener('touchend', handleMovieInteractionEnd);
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);

            videoVolumeBtn.addEventListener('click', (e) => { e.stopPropagation(); videoVolumeControls.classList.toggle('open'); });
            videoVolumeSlider.addEventListener('input', (e) => {
                const currentScene = getCurrentScene();
                if (currentScene && currentScene.backgroundType === 'video') { currentScene.backgroundElement.volume = e.target.value; }
            });
            videoVolumeControls.addEventListener('click', e => e.stopPropagation());
            
            canvasPlaceholder.addEventListener('click', () => initialBackgroundInput.click());
            canvasPanel.addEventListener('dragover', (e) => { e.preventDefault(); if (scenes.length === 0) canvasPanel.classList.add('drag-over'); });
            canvasPanel.addEventListener('dragleave', (e) => { e.preventDefault(); canvasPanel.classList.remove('drag-over'); });
            canvasPanel.addEventListener('drop', (e) => {
                e.preventDefault();
                canvasPanel.classList.remove('drag-over');
                if (scenes.length === 0) {
                    const file = e.dataTransfer.files[0];
                    if (file) handleBackgroundUpload(file, 'initial');
                }
            });

            shortcutsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                shortcutsDropdown.classList.toggle('visible');
                visualsDropdown.classList.remove('visible');
            });

            visualsBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                visualsDropdown.classList.toggle('visible');
                shortcutsDropdown.classList.remove('visible');
                if (visualsDropdown.classList.contains('visible')) {
                    updateVisualsUI();
                }
            });

            visualsDropdown.addEventListener('click', e => e.stopPropagation());

            assetOpacitySlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer) activeLayer.opacity = parseFloat(e.target.value);
            });
            assetBrightnessSlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer) activeLayer.brightness = parseFloat(e.target.value);
            });
            assetSaturationSlider.addEventListener('input', e => {
                const activeLayer = getActiveLayer();
                if (activeLayer) activeLayer.saturation = parseFloat(e.target.value);
            });
            bgBrightnessSlider.addEventListener('input', e => {
                const scene = getCurrentScene();
                if (scene) scene.bgBrightness = parseFloat(e.target.value);
            });
            bgSaturationSlider.addEventListener('input', e => {
                const scene = getCurrentScene();
                if (scene) scene.bgSaturation = parseFloat(e.target.value);
            });

            const allSliders = document.querySelectorAll('input[type="range"]');
            allSliders.forEach(slider => {
                const start = () => isDraggingSlider = true;
                slider.addEventListener('mousedown', start);
                slider.addEventListener('touchstart', start, { passive: true });
            });

            const allVisualsSliders = document.querySelectorAll('#visuals-dropdown input[type="range"]');
            
            const handleSliderScrubStart = (e) => {
                const sliderContainer = e.target.closest('.slider-container');
                if (sliderContainer) {
                    visualsDropdown.classList.add('is-scrubbing');
                    sliderContainer.classList.add('is-active-slider');
                }
            }

            const handleSliderScrubEnd = () => {
                visualsDropdown.classList.remove('is-scrubbing');
                const activeSlider = document.querySelector('.is-active-slider');
                if (activeSlider) {
                    activeSlider.classList.remove('is-active-slider');
                }
            }
            
            allVisualsSliders.forEach(slider => {
                slider.addEventListener('mousedown', handleSliderScrubStart);
                slider.addEventListener('touchstart', handleSliderScrubStart, { passive: true });
            });

            const endDrag = () => {
                setTimeout(() => { isDraggingSlider = false; }, 50);
                handleSliderScrubEnd();
            };

            window.addEventListener('mouseup', endDrag);
            window.addEventListener('touchend', endDrag);

            window.addEventListener('click', (e) => {
                if (isDraggingSlider) return;

                if (videoVolumeControls.classList.contains('open')) videoVolumeControls.classList.remove('open');
                if (shortcutsDropdown.classList.contains('visible')) shortcutsDropdown.classList.remove('visible');
                if (visualsDropdown.classList.contains('visible')) visualsDropdown.classList.remove('visible');
            });

            const canvasResizeObserver = new ResizeObserver(resizeCanvas);
            canvasResizeObserver.observe(canvasPanel);
        };

        updateControlsState();
        updateVisualsUI();
        setupEventListeners();
        startAnimationLoop();
    })();
</script>
</body>
</html>
